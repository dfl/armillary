<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ASC/MC Visualization - Analytic</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 4px;
  }
</style>
</head>
<body>

<div id="ui">
  Latitude: <input type="range" id="latSlider" min="-66" max="66" value="0" step="1">
  <span id="latValue">0°</span>
  <br>
  Time: <input type="range" id="timeSlider" min="0" max="1439" value="720" step="1">
  <span id="timeValue">12:00</span>
  <br>
  Day of Year: <input type="range" id="daySlider" min="1" max="365" value="1" step="1">
  <span id="dayValue">Jan 1</span>
</div>

<script type='text/javascript' src='./ephemeris-1.2.1.bundle.js' charset='utf-8'></script>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ------------------- Scene Setup -------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(4,4,4);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ------------------- Constants -------------------
const OBLIQUITY = 23.44 * Math.PI/180;
const CE_RADIUS = 3;

// ------------------- Groups -------------------
const celestial = new THREE.Group();
scene.add(celestial);

// ------------------- Fixed Reference Planes (green circles) -------------------
const planeOpts = { side: THREE.DoubleSide, transparent: true, opacity: 0.1 };

// Horizon plane (horizontal)
const horizonPlane = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, ...planeOpts })
);
horizonPlane.rotation.x = -Math.PI/2; // horizontal
scene.add(horizonPlane);

// Horizon outline
const horizonOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  horizonOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const horizonOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(horizonOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
horizonOutline.rotation.x = -Math.PI/2;
scene.add(horizonOutline);

// Meridian plane (vertical N/S)
const meridianPlane = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, ...planeOpts })
);
meridianPlane.rotation.y = Math.PI/2; // vertical N/S
scene.add(meridianPlane);

// Meridian outline
const meridianOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  meridianOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const meridianOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(meridianOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
meridianOutline.rotation.y = Math.PI/2;
scene.add(meridianOutline);
         

// Prime vertical plane (vertical E/W)
const pvPlane = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, ...planeOpts })
);
// No rotation needed - default XY plane is vertical E/W
scene.add(pvPlane);

// Prime vertical outline
const pvOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  pvOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const pvOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(pvOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
// No rotation needed - default XY plane is vertical E/W
scene.add(pvOutline);

// ------------------- Celestial Equator -------------------
const ceqPoints = [];
for(let i=0;i<=128;i++){
  const a=(i/128)*Math.PI*2;
  ceqPoints.push(new THREE.Vector3(CE_RADIUS*Math.cos(a), CE_RADIUS*Math.sin(a),0));
}
const ceqOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(ceqPoints),
  new THREE.LineDashedMaterial({color:0x00ffff, opacity:0.6, transparent:true, dashSize:0.5, gapSize:0.3})
);
ceqOutline.computeLineDistances();
// Celestial equator in XY plane (vertical at equator), poles along Z axis
celestial.add(ceqOutline);

// ------------------- Ecliptic -------------------
const ecliptic = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS,128),
  new THREE.MeshBasicMaterial({ color:0x888888, side:THREE.DoubleSide, transparent:true, opacity:0.1 })
);
ecliptic.rotation.x = OBLIQUITY; // Tilt from celestial equator around equinox line
celestial.add(ecliptic);

// ------------------- Zodiac Labels -------------------
const zodiacGroup = new THREE.Group();
zodiacGroup.rotation.x = OBLIQUITY; // Match ecliptic tilt
celestial.add(zodiacGroup);

// Radial lines at 0° of each zodiac sign (every 30°)
const radialLineMaterial = new THREE.LineBasicMaterial({color:0x888888, opacity:0.3, transparent:true});
for(let i=0; i<12; i++){
  const angle = THREE.MathUtils.degToRad(i*30);
  const radialLine = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0,0,0),
      new THREE.Vector3(CE_RADIUS*Math.cos(angle), CE_RADIUS*Math.sin(angle), 0)
    ]),
    radialLineMaterial
  );
  zodiacGroup.add(radialLine);
}

const zodiacRadius = 2.3;
const zodiacGlyphs = Array.from({length:12},(_,i)=>String.fromCodePoint(0x2648+i)+'\uFE0E');

zodiacGlyphs.forEach((glyph,i)=>{
  const angle = THREE.MathUtils.degToRad(i*30+15); // center at 15° of each sign
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 84px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(glyph,64,64);
  const texture = new THREE.CanvasTexture(canvas);
  const mat = new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.2,1.2),mat);
  mesh.position.set(zodiacRadius*Math.cos(angle), zodiacRadius*Math.sin(angle),0);
  mesh.rotation.z = angle + Math.PI/2;
  zodiacGroup.add(mesh);
});

// ------------------- Compass Labels -------------------
const compassRadius = 2.5;
function addCompassLabel(text,x,z,rotZ=0){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 64px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text,64,64);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat);
  mesh.position.set(x,0.01,z);
  mesh.rotation.x=-Math.PI/2;
  mesh.rotation.z=rotZ;
  scene.add(mesh);
}
addCompassLabel('N',0,compassRadius,0);
addCompassLabel('S',0,-compassRadius,Math.PI);
addCompassLabel('E',compassRadius,0,-Math.PI/2);
addCompassLabel('W',-compassRadius,0,Math.PI/2);

// ------------------- Celestial Poles -------------------
// Lines extending along polar axis (Z axis in celestial sphere's frame)
const polarLineMaterial = new THREE.LineBasicMaterial({color:0x00ffff, opacity:0.6, transparent:true});
const polarLineLength = 0.67;

const npLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, CE_RADIUS),
    new THREE.Vector3(0, 0, CE_RADIUS + polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(npLine);

const spLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, -CE_RADIUS),
    new THREE.Vector3(0, 0, -CE_RADIUS - polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(spLine);

// Labels at the ends of the polar axis lines
function addPoleLabel(name,z){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=64;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='24px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(name,64,32);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.SpriteMaterial({map:texture, depthTest:false});
  const sprite=new THREE.Sprite(mat);
  sprite.scale.set(1,0.5,1);
  sprite.position.set(0,0,z);
  celestial.add(sprite);
}
addPoleLabel('NP', CE_RADIUS+polarLineLength);
addPoleLabel('SP', -CE_RADIUS-polarLineLength);

// ------------------- Sun -------------------
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(0.15,32,32),
  new THREE.MeshBasicMaterial({color:0xffff88})
);
zodiacGroup.add(sun); // Add to zodiacGroup so it's on the ecliptic plane

// ------------------- Sliders -------------------
let currentLatitude=0;
let currentTime=720;
let currentDay=1;

const latSlider=document.getElementById('latSlider');
const latValue=document.getElementById('latValue');
const timeSlider=document.getElementById('timeSlider');
const timeValue=document.getElementById('timeValue');
const daySlider=document.getElementById('daySlider');
const dayValue=document.getElementById('dayValue');

function dayToStr(day){
  const md=[31,29,31,30,31,30,31,31,30,31,30,31];
  const mn=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  let d=day;
  for(let i=0;i<12;i++){
    if(d<=md[i]) return `${mn[i]} ${d}`;
    d-=md[i];
  }
  return 'Dec 31';
}

// ------------------- Celestial Sphere Update -------------------
function updateSphere(){
  const latRad = THREE.MathUtils.degToRad(currentLatitude);
  const hourAngle = (currentTime/1440)*Math.PI*2; // diurnal
  const yearAngle = ((currentDay-1)/365)*Math.PI*2; // annual

  // Set rotation order: X rotation (latitude tilt) then Z rotation (hour angle)
  celestial.rotation.order = 'XZY';
  celestial.rotation.x = -latRad; // Tilt polar axis from north (Z) towards zenith (Y)
  celestial.rotation.z = (hourAngle + yearAngle); // Rotate around tilted polar axis (positive = E to W motion)
  celestial.rotation.y = 0;

  // Sun position
  let sunLonRad;

  // Try to use ephemeris if available, otherwise use simple approximation
  if (typeof $moshier !== 'undefined') {
    // TODO: Use proper Moshier Ephemeris API once library is loaded
    // For now, fall back to approximation
    const sunLon = (280 + (currentDay-1)*(360/365))%360;
    sunLonRad = THREE.MathUtils.degToRad(sunLon);
  } else {
    // Simple approximation for year 2000
    const sunLon = (280 + (currentDay-1)*(360/365))%360;
    sunLonRad = THREE.MathUtils.degToRad(sunLon);
  }

  // Position Sun on ecliptic (in zodiacGroup's coordinate system)
  sun.position.set(CE_RADIUS*Math.cos(sunLonRad), CE_RADIUS*Math.sin(sunLonRad), 0);

  // ------------------- Analytic Angles: MC, IC, AC, DSC -------------------
  // MC: projection of celestial pole onto local meridian
  const sinLat = Math.sin(latRad);
  const cosLat = Math.cos(latRad);
  const mcVec = new THREE.Vector3(0, cosLat, sinLat).normalize(); // Midheaven vector
  spheres["MC"].position.copy(mcVec.clone().multiplyScalar(CE_RADIUS));
  spheres["IC"].position.copy(mcVec.clone().multiplyScalar(-CE_RADIUS));

  // Ascendant vector: intersection of horizon with ecliptic plane along east
  const acVec = new THREE.Vector3(cosLat,0,-sinLat).normalize();
  spheres["ASC"].position.copy(acVec.clone().multiplyScalar(CE_RADIUS));
  spheres["DSC"].position.copy(acVec.clone().multiplyScalar(-CE_RADIUS));
}

// ------------------- Angle Spheres -------------------
const spheres={};
function addAngle(name,color){
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(0.12,16,16),
    new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.6})
  );
  scene.add(mesh); // Add to scene, not celestial - these are horizon-fixed angles
  spheres[name]=mesh;
}
addAngle("MC",0xff0000);
addAngle("IC",0xff0000);
addAngle("ASC",0xff0000);
addAngle("DSC",0xff0000);

// ------------------- Slider Listeners -------------------
latSlider.addEventListener('input',()=>{currentLatitude=parseFloat(latSlider.value);latValue.textContent=currentLatitude+"°";updateSphere();});
timeSlider.addEventListener('input',()=>{currentTime=parseFloat(timeSlider.value);let h=Math.floor(currentTime/60);let m=currentTime%60;timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;updateSphere();});
daySlider.addEventListener('input',()=>{currentDay=parseFloat(daySlider.value);dayValue.textContent=`Day ${currentDay}: ${dayToStr(currentDay)}`;updateSphere();});

// ------------------- Animate -------------------
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}

currentLatitude=parseFloat(latSlider.value);
currentTime=parseFloat(timeSlider.value);
currentDay=parseFloat(daySlider.value);
latValue.textContent=currentLatitude+"°";
let h=Math.floor(currentTime/60), m=currentTime%60;
timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
dayValue.textContent=`Day ${currentDay}: ${dayToStr(currentDay)}`;
updateSphere();
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
