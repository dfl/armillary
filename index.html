<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ASC/MC Visualization - Circular Planes</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 4px;
  }
</style>
</head>
<body>

<div id="ui">
  Latitude: <input type="range" id="latSlider" min="-66" max="66" value="0" step="1">
  <span id="latValue">0°</span>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ------------------- Scene Setup -------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(8,8,8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ------------------- Planes (Circular) -------------------
const planeOpts = { side: THREE.DoubleSide, transparent: true, opacity: 0.1 };

const OBLIQUITY = 23.44 * Math.PI/180;

// Horizon circle (blue) - FIXED HORIZONTAL - this is our reference plane
const horizonPlane = new THREE.Mesh(
  new THREE.CircleGeometry(3, 64),
  new THREE.MeshBasicMaterial({ color: 0x0000ff, ...planeOpts })
);
horizonPlane.rotation.x = -Math.PI/2; // Horizontal (XZ plane)
scene.add(horizonPlane);

// Create a group for celestial sphere elements that rotate with latitude
const celestialGroup = new THREE.Group();
scene.add(celestialGroup);

// Celestial Equator (cyan) - will rotate with latitude
const celestialEquatorPlane = new THREE.Mesh(
  new THREE.CircleGeometry(3, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ffff, ...planeOpts })
);
celestialEquatorPlane.rotation.x = -Math.PI/2;
celestialGroup.add(celestialEquatorPlane);

// Meridian circle (green) - vertical N-S plane
const meridianPlane = new THREE.Mesh(
  new THREE.CircleGeometry(3, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, ...planeOpts })
);
meridianPlane.rotation.y = Math.PI/2; // Make it vertical in YZ plane
celestialGroup.add(meridianPlane);

// Ecliptic circle (red) - tilted by obliquity from celestial equator
const eclipticPlane = new THREE.Mesh(
  new THREE.CircleGeometry(3, 64),
  new THREE.MeshBasicMaterial({ color: 0xff0000, ...planeOpts })
);
eclipticPlane.rotation.x = -Math.PI/2;
eclipticPlane.rotation.z = OBLIQUITY;
celestialGroup.add(eclipticPlane);

// Prime Vertical circle (hollow outline) - vertical E-W plane
const primeVerticalPoints = [];
const pvRadius = 3;
const pvSegments = 64;
for (let i = 0; i <= pvSegments; i++) {
  const angle = (i / pvSegments) * Math.PI * 2;
  primeVerticalPoints.push(new THREE.Vector3(
    pvRadius * Math.cos(angle),
    pvRadius * Math.sin(angle),
    0
  ));
}
const primeVerticalGeometry = new THREE.BufferGeometry().setFromPoints(primeVerticalPoints);
const primeVerticalLine = new THREE.Line(
  primeVerticalGeometry,
  new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2 })
);
celestialGroup.add(primeVerticalLine);

// ------------------- Spheres -------------------
const spheres = {};
function addSphere(name, pos, color, addToCelestialGroup = true){
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.12,16,16),
    new THREE.MeshBasicMaterial({color})
  );
  mesh.position.copy(pos);
  if (addToCelestialGroup) {
    celestialGroup.add(mesh);
  } else {
    scene.add(mesh);
  }
  spheres[name] = mesh;

  const spriteMaterial = new THREE.SpriteMaterial({
    map: new THREE.CanvasTexture((() => {
      const c = document.createElement('canvas');
      c.width = 128; c.height = 64;
      const ctx = c.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.fillText(name,10,40);
      return c;
    })()),
    depthTest:false
  });
  const sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(1,0.5,1);
  sprite.position.copy(pos).add(new THREE.Vector3(0,0.2,0));
  if (addToCelestialGroup) {
    celestialGroup.add(sprite);
  } else {
    scene.add(sprite);
  }
}

// ASC/DSC are on the horizon at east/west points
addSphere("ASC", new THREE.Vector3(3,0,0), 0xffff00);
addSphere("DSC", new THREE.Vector3(-3,0,0), 0xffff00);

// MC/IC are where the meridian intersects the ecliptic
// Meridian is at x=0, so we need points on ecliptic where x=0
// This occurs at 90° and 270° on the ecliptic
const mcAngleOnEcliptic = 90 * Math.PI/180;  // Near Cancer
const icAngleOnEcliptic = 270 * Math.PI/180; // Near Capricorn

const mcPos = new THREE.Vector3(
  0,  // On meridian (x=0)
  3 * Math.sin(mcAngleOnEcliptic) * Math.cos(OBLIQUITY),
  3 * Math.sin(mcAngleOnEcliptic) * Math.sin(OBLIQUITY)
);

const icPos = new THREE.Vector3(
  0,  // On meridian (x=0)
  3 * Math.sin(icAngleOnEcliptic) * Math.cos(OBLIQUITY),
  3 * Math.sin(icAngleOnEcliptic) * Math.sin(OBLIQUITY)
);

addSphere("MC", mcPos, 0xff00ff);
addSphere("IC", icPos, 0xff00ff);

// ------------------- Cardinal Cross on Ecliptic -------------------
// Cardinal points are placed on the ecliptic plane
// We need to account for the obliquity tilt when placing them

const radius = 3;
const cardinalPoints = [
  { name: "Aries ♈", angle: 0, color: 0xff6b6b },      // 0° - Spring Equinox
  { name: "Cancer ♋", angle: 90, color: 0x4ecdc4 },    // 90° - Summer Solstice
  { name: "Libra ♎", angle: 180, color: 0xffe66d },    // 180° - Autumn Equinox
  { name: "Capricorn ♑", angle: 270, color: 0x95e1d3 } // 270° - Winter Solstice
];

cardinalPoints.forEach(point => {
  const angleRad = THREE.MathUtils.degToRad(point.angle);

  // Position on ecliptic plane (tilted by obliquity)
  // The ecliptic is rotated around the X-axis
  const x = radius * Math.cos(angleRad);
  const y = radius * Math.sin(angleRad) * Math.cos(OBLIQUITY);
  const z = radius * Math.sin(angleRad) * Math.sin(OBLIQUITY);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.15, 16, 16),
    new THREE.MeshBasicMaterial({ color: point.color })
  );
  mesh.position.set(x, y, z);
  celestialGroup.add(mesh);

  // Label
  const spriteMaterial = new THREE.SpriteMaterial({
    map: new THREE.CanvasTexture((() => {
      const c = document.createElement('canvas');
      c.width = 256; c.height = 64;
      const ctx = c.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.font = 'bold 28px Arial';
      ctx.fillText(point.name, 10, 40);
      return c;
    })()),
    depthTest: false
  });
  const sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(1.5, 0.75, 1);
  sprite.position.set(x, y, z).add(new THREE.Vector3(0, 0.3, 0));
  celestialGroup.add(sprite);
});

// Draw the Cardinal Cross lines
const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.6, transparent: true });

// Aries-Libra axis (equinoctial)
const ariesPos = new THREE.Vector3(radius, 0, 0);
const libraPos = new THREE.Vector3(-radius, 0, 0);
const equinoxLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([ariesPos, libraPos]),
  lineMaterial
);
celestialGroup.add(equinoxLine);

// Cancer-Capricorn axis (solstitial)
const cancerAngle = THREE.MathUtils.degToRad(90);
const capricornAngle = THREE.MathUtils.degToRad(270);

const cancerPos = new THREE.Vector3(
  radius * Math.cos(cancerAngle),
  radius * Math.sin(cancerAngle) * Math.cos(OBLIQUITY),
  radius * Math.sin(cancerAngle) * Math.sin(OBLIQUITY)
);

const capricornPos = new THREE.Vector3(
  radius * Math.cos(capricornAngle),
  radius * Math.sin(capricornAngle) * Math.cos(OBLIQUITY),
  radius * Math.sin(capricornAngle) * Math.sin(OBLIQUITY)
);

const solsticeLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([cancerPos, capricornPos]),
  lineMaterial
);
celestialGroup.add(solsticeLine);

// ------------------- Latitude Update -------------------
function updateForLatitude(latDeg){
  const latRad = THREE.MathUtils.degToRad(latDeg);

  // Horizon stays FIXED (horizontal)
  // Rotate the entire celestial sphere around the east-west axis (Z-axis in our setup)
  // At equator (0°): celestial equator is vertical, poles on horizon
  // At pole (90°): celestial equator is horizontal, pole at zenith
  celestialGroup.rotation.z = latRad;
}

// ------------------- Slider -------------------
const latSlider = document.getElementById('latSlider');
const latValue = document.getElementById('latValue');

latSlider.addEventListener('input', ()=>{
  const val = parseFloat(latSlider.value);
  latValue.textContent = val.toFixed(1) + "°";
  updateForLatitude(val);
});
updateForLatitude(parseFloat(latSlider.value));

// ------------------- Animate -------------------
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
