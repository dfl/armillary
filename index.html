<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ASC/MC Visualization - Analytic</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 4px;
  }
  #angles {
    position: absolute;
    top: 10px;
    right: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 4px;
    min-width: 150px;
  }
  #angles div {
    margin: 4px 0;
  }
  .angle-label {
    font-weight: bold;
  }
  #sunTimes {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 4px;
    min-width: 150px;
  }
  #sunTimes div {
    margin: 4px 0;
  }
  .time-label {
    font-weight: bold;
  }
</style>
</head>
<body>

<div id="ui">
  Latitude: <input type="range" id="latSlider" min="-66" max="66" value="0" step="1">
  <span id="latValue">0°</span>
  <br>
  Longitude: <input type="range" id="lonSlider" min="-180" max="180" value="0" step="1">
  <span id="lonValue">0°</span>
  <br>
  Time: <input type="range" id="timeSlider" min="0" max="1439" value="720" step="1">
  <span id="timeValue">12:00</span>
  <br>
  Day of Year: <input type="range" id="daySlider" min="1" max="365" value="1" step="1">
  <span id="dayValue">Jan 1</span>
</div>

<div id="angles">
  <div><span class="angle-label">LST:</span> <span id="lstValue">--</span></div>
  <div><span class="angle-label">MC:</span> <span id="mcValue">--</span></div>
  <div><span class="angle-label">AC:</span> <span id="acValue">--</span></div>
</div>

<div id="sunTimes">
  <div><span class="time-label">Sunrise:</span> <span id="sunriseValue">--</span></div>
  <div><span class="time-label">Sunset:</span> <span id="sunsetValue">--</span></div>
</div>

<script type='text/javascript' src='./ephemeris-1.2.1.bundle.js' charset='utf-8'></script>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ------------------- Scene Setup -------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(4,4,4);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// ------------------- Constants -------------------
const OBLIQUITY = 23.44 * Math.PI/180;
const CE_RADIUS = 3;

// ------------------- Groups -------------------
const celestial = new THREE.Group();
scene.add(celestial);

// ------------------- Fixed Reference Planes (green circles) -------------------
const planeOpts = { side: THREE.DoubleSide, transparent: true, opacity: 0.1 };

// Horizon plane (horizontal)
const horizonPlane = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, ...planeOpts })
);
horizonPlane.rotation.x = -Math.PI/2; // horizontal
scene.add(horizonPlane);

// Horizon outline
const horizonOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  horizonOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const horizonOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(horizonOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
horizonOutline.rotation.x = -Math.PI/2;
scene.add(horizonOutline);

// Meridian outline (no filled plane, only outline)
const meridianOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  meridianOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const meridianOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(meridianOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
meridianOutline.rotation.y = Math.PI/2;
scene.add(meridianOutline);

// Prime vertical outline (no filled plane, only outline)
const pvOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  pvOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const pvOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(pvOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
// No rotation needed - default XY plane is vertical E/W
scene.add(pvOutline);

// ------------------- Celestial Equator -------------------
const ceqPoints = [];
for(let i=0;i<=128;i++){
  const a=(i/128)*Math.PI*2;
  ceqPoints.push(new THREE.Vector3(CE_RADIUS*Math.cos(a), CE_RADIUS*Math.sin(a),0));
}
const ceqOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(ceqPoints),
  new THREE.LineDashedMaterial({color:0x00ffff, opacity:0.6, transparent:true, dashSize:0.5, gapSize:0.3})
);
ceqOutline.computeLineDistances();
// Celestial equator in XY plane (vertical at equator), poles along Z axis
celestial.add(ceqOutline);

// ------------------- Ecliptic -------------------
const ecliptic = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS,128),
  new THREE.MeshBasicMaterial({ color:0x888888, side:THREE.DoubleSide, transparent:true, opacity:0.1 })
);
ecliptic.rotation.x = OBLIQUITY; // Tilt from celestial equator around equinox line
celestial.add(ecliptic);

// ------------------- Zodiac Labels -------------------
const zodiacGroup = new THREE.Group();
zodiacGroup.rotation.x = OBLIQUITY; // Match ecliptic tilt
celestial.add(zodiacGroup);

// Radial lines at 0° of each zodiac sign (every 30°)
const radialLineMaterial = new THREE.LineBasicMaterial({color:0x888888, opacity:0.3, transparent:true});
for(let i=0; i<12; i++){
  const angle = THREE.MathUtils.degToRad(i*30);
  const radialLine = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0,0,0),
      new THREE.Vector3(CE_RADIUS*Math.cos(angle), CE_RADIUS*Math.sin(angle), 0)
    ]),
    radialLineMaterial
  );
  zodiacGroup.add(radialLine);
}

const zodiacRadius = 2.3;
const zodiacGlyphs = Array.from({length:12},(_,i)=>String.fromCodePoint(0x2648+i)+'\uFE0E');

zodiacGlyphs.forEach((glyph,i)=>{
  const angle = THREE.MathUtils.degToRad(i*30+15); // center at 15° of each sign
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 84px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(glyph,64,64);
  const texture = new THREE.CanvasTexture(canvas);
  const mat = new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.2,1.2),mat);
  mesh.position.set(zodiacRadius*Math.cos(angle), zodiacRadius*Math.sin(angle),0);
  mesh.rotation.z = angle + Math.PI/2;
  zodiacGroup.add(mesh);
});

// ------------------- Compass Labels -------------------
const compassRadius = 2.5;
function addCompassLabel(text,x,z,rotZ=0){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 64px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text,64,64);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat);
  mesh.position.set(x,0.01,z);
  mesh.rotation.x=-Math.PI/2;
  mesh.rotation.z=rotZ;
  scene.add(mesh);
}
addCompassLabel('N',0,compassRadius,0);
addCompassLabel('S',0,-compassRadius,Math.PI);
addCompassLabel('E',compassRadius,0,-Math.PI/2);
addCompassLabel('W',-compassRadius,0,Math.PI/2);

// ------------------- Celestial Poles -------------------
// Lines extending along polar axis (Z axis in celestial sphere's frame)
const polarLineMaterial = new THREE.LineBasicMaterial({color:0x00ffff, opacity:0.6, transparent:true});
const polarLineLength = 0.67;

const npLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, CE_RADIUS),
    new THREE.Vector3(0, 0, CE_RADIUS + polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(npLine);

const spLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, -CE_RADIUS),
    new THREE.Vector3(0, 0, -CE_RADIUS - polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(spLine);

// Labels at the ends of the polar axis lines
function addPoleLabel(name,z){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=64;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='24px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(name,64,32);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.SpriteMaterial({map:texture, depthTest:false});
  const sprite=new THREE.Sprite(mat);
  sprite.scale.set(1,0.5,1);
  sprite.position.set(0,0,z);
  celestial.add(sprite);
}
addPoleLabel('NP', CE_RADIUS+polarLineLength);
addPoleLabel('SP', -CE_RADIUS-polarLineLength);

// ------------------- Sun -------------------
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(0.15,32,32),
  new THREE.MeshBasicMaterial({color:0xffff88})
);
zodiacGroup.add(sun); // Add to zodiacGroup so it's on the ecliptic plane

// Add sun glow effect
const sunGlow = new THREE.Mesh(
  new THREE.SphereGeometry(0.25, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0xffff00,
    transparent: true,
    opacity: 0.3
  })
);
zodiacGroup.add(sunGlow);

// ------------------- Sliders -------------------
let currentLatitude=0;
let currentLongitude=0;
let currentTime=720;
let currentDay=1;

const latSlider=document.getElementById('latSlider');
const latValue=document.getElementById('latValue');
const lonSlider=document.getElementById('lonSlider');
const lonValue=document.getElementById('lonValue');
const timeSlider=document.getElementById('timeSlider');
const timeValue=document.getElementById('timeValue');
const daySlider=document.getElementById('daySlider');
const dayValue=document.getElementById('dayValue');

function dayToStr(day){
  const md=[31,29,31,30,31,30,31,31,30,31,30,31];
  const mn=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  let d=day;
  for(let i=0;i<12;i++){
    if(d<=md[i]) return `${mn[i]} ${d}`;
    d-=md[i];
  }
  return 'Dec 31';
}

// ------------------- Celestial Sphere Update -------------------
function updateSphere(){
  const latRad = THREE.MathUtils.degToRad(currentLatitude);

  // Adjust time for longitude: 15° longitude = 1 hour time difference
  // Longitude is positive East, so positive longitude means earlier solar time
  const longitudeTimeOffset = (currentLongitude / 15) * 60; // Convert to minutes
  const localTime = currentTime + longitudeTimeOffset;

  const hourAngle = (localTime/1440)*Math.PI*2; // diurnal
  const yearAngle = ((currentDay-1)/365)*Math.PI*2; // annual

  // Set rotation order: X rotation (latitude tilt) then Z rotation (hour angle)
  celestial.rotation.order = 'XZY';
  celestial.rotation.x = -latRad; // Tilt polar axis from north (Z) towards zenith (Y)
  celestial.rotation.z = (hourAngle + yearAngle); // Rotate around tilted polar axis (positive = E to W motion)
  celestial.rotation.y = 0;

  // Sun position - Convert day of year to month/day
  let sunLonRad;
  let sunBodyData = null; // Save for rise/set calculation

  // Convert day of year (1-365) to month and day
  const monthDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 2000 is leap year
  let remainingDays = currentDay;
  let month = 0;
  let day = 1;
  for (let i = 0; i < 12; i++) {
    if (remainingDays <= monthDays[i]) {
      month = i;
      day = remainingDays;
      break;
    }
    remainingDays -= monthDays[i];
  }

  // Convert time (minutes since midnight) to hours/minutes
  const hours = Math.floor(currentTime / 60);
  const minutes = currentTime % 60;

  // Use ephemeris if available, otherwise fall back to approximation
  if (typeof $moshier !== 'undefined') {
    try {
      // Set observer location
      $const.tlong = currentLongitude;  // Observer longitude
      $const.glat = currentLatitude;  // Observer latitude

      // Set date
      const date = {
        year: 2000,
        month: month + 1,  // Moshier uses 1-12, not 0-11
        day: day,
        hours: hours,
        minutes: minutes,
        seconds: 0
      };

      // Initialize and calculate
      $processor.init();
      const body = $moshier.body.sun;
      $processor.calc(date, body);
      sunBodyData = body; // Save for later use

      // Get Sun's ecliptic longitude from the result
      // The ecliptic longitude should be in body.position.rect or body.position.polar
      // Moshier returns longitude in radians in body.position.longitude or similar
      if (body.position && body.position.apparentLongitude !== undefined) {
        sunLonRad = THREE.MathUtils.degToRad(body.position.apparentLongitude);
      } else if (body.position && body.position.polar) {
        sunLonRad = THREE.MathUtils.degToRad(body.position.polar[0]);
      } else {
        // Fallback to approximation if structure is unexpected
        console.warn('Unexpected ephemeris data structure, using approximation');
        const sunLon = (280 + (currentDay-1)*(360/365))%360;
        sunLonRad = THREE.MathUtils.degToRad(sunLon);
      }
    } catch (e) {
      console.warn('Ephemeris calculation failed, using approximation:', e);
      // Fallback to approximation
      const sunLon = (280 + (currentDay-1)*(360/365))%360;
      sunLonRad = THREE.MathUtils.degToRad(sunLon);
    }
  } else {
    // Simple approximation for year 2000
    const sunLon = (280 + (currentDay-1)*(360/365))%360;
    sunLonRad = THREE.MathUtils.degToRad(sunLon);
  }

  // Position Sun on ecliptic (in zodiacGroup's coordinate system)
  // Offset slightly above ecliptic plane (positive Z) to avoid being blocked by ecliptic fill
  sun.position.set(CE_RADIUS*Math.cos(sunLonRad), CE_RADIUS*Math.sin(sunLonRad), 0.05);
  sunGlow.position.copy(sun.position);

  // ------------------- Analytic Angles: MC, IC, AC, DSC -------------------
  // MC: projection of celestial pole onto local meridian
  const sinLat = Math.sin(latRad);
  const cosLat = Math.cos(latRad);
  const mcVec = new THREE.Vector3(0, cosLat, sinLat).normalize(); // Midheaven vector
  spheres["MC"].position.copy(mcVec.clone().multiplyScalar(CE_RADIUS));
  spheres["IC"].position.copy(mcVec.clone().multiplyScalar(-CE_RADIUS));

  // Ascendant vector: intersection of horizon with ecliptic plane along east
  const acVec = new THREE.Vector3(cosLat,0,-sinLat).normalize();
  spheres["ASC"].position.copy(acVec.clone().multiplyScalar(CE_RADIUS));
  spheres["DSC"].position.copy(acVec.clone().multiplyScalar(-CE_RADIUS));

  // ------------------- Calculate LST, MC, AC in Zodiac Degrees -------------------
  // Local Sidereal Time (LST) calculation
  // Simplified: LST = hour angle + right ascension offset for the day
  const J2000_epoch = 2451545.0; // Julian date for J2000.0
  const daysFromJ2000 = (currentDay - 1) + (localTime / 1440); // Fractional days in year 2000
  const julianDate = 2451544.5 + daysFromJ2000; // Approximate JD for year 2000

  // Greenwich Sidereal Time at 0h UT (simplified formula)
  const T = (julianDate - J2000_epoch) / 36525; // Julian centuries from J2000.0
  const GST0 = 280.46061837 + 360.98564736629 * (julianDate - J2000_epoch) + 0.000387933 * T * T;

  // Local Sidereal Time = GST + longitude (in degrees)
  let LST = (GST0 + currentLongitude + (localTime / 1440) * 360) % 360;
  if (LST < 0) LST += 360;

  // MC (Midheaven) = Local Sidereal Time converted to ecliptic longitude
  // For simplicity, MC ≈ LST (this is approximate; exact formula involves RAMC conversion)
  let MC = LST;

  // AC (Ascendant) calculation using standard formula
  // tan(AC) = cos(MC) / (-sin(MC)*cos(ε) - tan(lat)*sin(ε))
  const epsilon = OBLIQUITY; // Obliquity of ecliptic
  const mcRad = THREE.MathUtils.degToRad(MC);
  const tanLat = Math.tan(latRad);

  const acNumerator = Math.cos(mcRad);
  const acDenominator = -Math.sin(mcRad) * Math.cos(epsilon) - tanLat * Math.sin(epsilon);
  let AC = THREE.MathUtils.radToDeg(Math.atan2(acNumerator, acDenominator));
  if (AC < 0) AC += 360;

  // Convert to zodiac notation (sign + degree)
  function toZodiacString(longitude) {
    const signs = ['♈\uFE0E', '♉\uFE0E', '♊\uFE0E', '♋\uFE0E', '♌\uFE0E', '♍\uFE0E', '♎\uFE0E', '♏\uFE0E', '♐\uFE0E', '♑\uFE0E', '♒\uFE0E', '♓\uFE0E'];
    const signIndex = Math.floor(longitude / 30);
    const degree = longitude % 30;
    const minutes = Math.floor((degree % 1) * 60);
    const wholeDegs = Math.floor(degree);
    return `${wholeDegs.toString().padStart(2, '0')}${signs[signIndex]}${minutes.toString().padStart(2, '0')}`;
  }

  function lstToTimeString(lst) {
    const hours = Math.floor(lst / 15);
    const minutes = Math.floor((lst % 15) * 4);
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }

  // Update display
  document.getElementById('lstValue').textContent = lstToTimeString(LST);
  document.getElementById('mcValue').textContent = toZodiacString(MC);
  document.getElementById('acValue').textContent = toZodiacString(AC);

  // ------------------- Calculate Sunrise and Sunset -------------------
  // These values should only depend on date and location, not time of day
  let sunriseTime = "--:--";
  let sunsetTime = "--:--";

  console.log('sunBodyData:', sunBodyData);

  if (sunBodyData) {
    console.log('Checking for rise/set in ephemeris data');
    console.log('Rise:', sunBodyData.rise, 'Set:', sunBodyData.set);
    console.log('Full body:', JSON.stringify(sunBodyData, null, 2));

    try {
      // Check if ephemeris provides rise/set times
      if (sunBodyData.rise && sunBodyData.set) {
        console.log('Using ephemeris rise/set times');
        // Format ephemeris rise/set times
        function formatRiseSetTime(timeData) {
          if (typeof timeData === 'string') return timeData;
          if (timeData.hours !== undefined) {
            const h = timeData.hours;
            const m = timeData.minutes || 0;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
          }
          return "--:--";
        }
        sunriseTime = formatRiseSetTime(sunBodyData.rise);
        sunsetTime = formatRiseSetTime(sunBodyData.set);
      } else {
        console.log('Ephemeris does not provide rise/set, using manual calculation');
        // Fallback: calculate manually (independent of time slider)
        const sunDeclination = Math.asin(Math.sin(sunLonRad) * Math.sin(epsilon));
        const sunAltitude = -0.833 * Math.PI / 180;
        const cosH = (Math.sin(sunAltitude) - Math.sin(latRad) * Math.sin(sunDeclination)) /
                     (Math.cos(latRad) * Math.cos(sunDeclination));

        if (cosH > 1) {
          sunriseTime = "No sunrise";
          sunsetTime = "No sunset";
        } else if (cosH < -1) {
          sunriseTime = "Midnight sun";
          sunsetTime = "Midnight sun";
        } else {
          const H = Math.acos(cosH) * 180 / Math.PI;
          const sunRA = Math.atan2(Math.sin(sunLonRad) * Math.cos(epsilon), Math.cos(sunLonRad));
          const sunRADeg = THREE.MathUtils.radToDeg(sunRA);
          let transitLST = sunRADeg < 0 ? sunRADeg + 360 : sunRADeg;

          // Calculate GST at 0h for this day (independent of current time)
          const julianDate0h = 2451544.5 + (currentDay - 1);
          const T0 = (julianDate0h - J2000_epoch) / 36525;
          const GST0_day = 280.46061837 + 360.98564736629 * (julianDate0h - J2000_epoch) + 0.000387933 * T0 * T0;

          const transitTime = ((transitLST - GST0_day - currentLongitude) / 360) * 1440;
          const sunriseMinutes = transitTime - (H / 15) * 60;
          const sunsetMinutes = transitTime + (H / 15) * 60;

          function formatTime(minutes) {
            let m = ((minutes % 1440) + 1440) % 1440;
            const h = Math.floor(m / 60);
            const min = Math.floor(m % 60);
            return `${h.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
          }

          sunriseTime = formatTime(sunriseMinutes);
          sunsetTime = formatTime(sunsetMinutes);
        }
      }
    } catch (e) {
      console.warn('Sunrise/sunset calculation failed:', e);
      sunriseTime = "Error";
      sunsetTime = "Error";
    }
  }

  console.log('Final sunrise/sunset:', sunriseTime, sunsetTime);
  document.getElementById('sunriseValue').textContent = sunriseTime;
  document.getElementById('sunsetValue').textContent = sunsetTime;
}

// ------------------- Angle Spheres -------------------
const spheres={};
function addAngle(name,color){
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(0.12,16,16),
    new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.6})
  );
  scene.add(mesh); // Add to scene, not celestial - these are horizon-fixed angles
  spheres[name]=mesh;
}
addAngle("MC",0xff0000);
addAngle("IC",0xff0000);
addAngle("ASC",0xff0000);
addAngle("DSC",0xff0000);

// ------------------- Slider Listeners -------------------
latSlider.addEventListener('input',()=>{currentLatitude=parseFloat(latSlider.value);latValue.textContent=currentLatitude+"°";updateSphere();});
lonSlider.addEventListener('input',()=>{currentLongitude=parseFloat(lonSlider.value);lonValue.textContent=currentLongitude+"°";updateSphere();});
timeSlider.addEventListener('input',()=>{currentTime=parseFloat(timeSlider.value);let h=Math.floor(currentTime/60);let m=currentTime%60;timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;updateSphere();});
daySlider.addEventListener('input',()=>{currentDay=parseFloat(daySlider.value);dayValue.textContent=`Day ${currentDay}: ${dayToStr(currentDay)}`;updateSphere();});

// ------------------- Animate -------------------
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}

currentLatitude=parseFloat(latSlider.value);
currentLongitude=parseFloat(lonSlider.value);
currentTime=parseFloat(timeSlider.value);
currentDay=parseFloat(daySlider.value);
latValue.textContent=currentLatitude+"°";
lonValue.textContent=currentLongitude+"°";
let h=Math.floor(currentTime/60), m=currentTime%60;
timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
dayValue.textContent=`Day ${currentDay}: ${dayToStr(currentDay)}`;
updateSphere();
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
