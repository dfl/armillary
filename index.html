<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ASC/MC Visualization - Analytic</title>
<style>
  body { margin: 0; overflow: hidden; }
  input[type="text"] {
    border-radius: 0.5rem;
    border: 1px solid #ddd;
    padding: 0.25rem 0.5rem;
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 0.5rem;
  }
  #angles {
    position: absolute;
    top: 10px;
    right: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 0.5rem;
    min-width: 150px;
  }
  #angles div {
    margin: 4px 0;
  }
  .angle-label {
    font-weight: bold;
  }
  #sunTimes {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 0.5rem;
    min-width: 150px;
  }
  #sunTimes div {
    margin: 4px 0;
  }
  .time-label {
    font-weight: bold;
  }
  #starInfo {
    position: absolute;
    bottom: 10px;
    right: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 0.5rem;
    min-width: 200px;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 500ms ease-in-out;
  }
  #starInfo.visible {
    opacity: 1;
    pointer-events: auto;
  }
  #starInfo .star-name {
    font-weight: bold;
    font-size: 18px;
    margin-bottom: 4px;
  }
  #starInfo .constellation-name {
    font-size: 14px;
    color: #aaaaff;
  }

  /* Autocomplete custom styles */
  .autoComplete_wrapper {
    display: inline-block;
    position: relative;
  }

  #locationInput {
    border-radius: 0.5rem;
    border: 1px solid #ddd;
    padding: 0.5rem 0.5rem 0.5rem 2.25rem;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23666' viewBox='0 0 16 16'%3E%3Cpath d='M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: 0.75rem center;
    background-size: 1rem;
  }

  #autoComplete_list_1 {
    position: absolute;
    max-height: 300px;
    overflow-y: auto;
    background-color: #000;
    border: 1px solid #333;
    border-radius: 0.5rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    z-index: 9999;
    list-style: none;
    margin: 2px 0 0 0;
    padding: 0;
  }

  #autoComplete_list_1 li {
    padding: 8px 12px;
    color: #fff;
    cursor: pointer;
    border-bottom: 1px solid #333;
  }

  #autoComplete_list_1 li:first-child {
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
  }

  #autoComplete_list_1 li:last-child {
    border-bottom: none;
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
  }

  #autoComplete_list_1 li:hover,
  #autoComplete_list_1 li[aria-selected="true"] {
    background-color: #333;
  }

  #autoComplete_list_1 mark {
    background-color: transparent;
    color: #fff;
    font-weight: bold;
  }
</style>
</head>
<body>

<div id="ui">
  DateTime: <input type="text" id="datetimeInput" placeholder="e.g., 'now', '2000-03-21 12:00', 'March 21 2000 noon'" style="width: 300px;">
  <button id="nowButton">Now</button>
  <br>
  <br>
  Location: <input type="text" id="locationInput" placeholder="Search for a city..." style="width: 300px;">
  <br>
  <br>
  Latitude: <input type="text" id="latInput" placeholder="e.g., 40.7128, -33.8688" style="width: 80px;">
  <input type="range" id="latSlider" min="-66" max="66" value="0" step="0.1">
  <span id="latValue">0°</span>
  <br>
  Longitude: <input type="text" id="lonInput" placeholder="e.g., -74.0060, 151.2093" style="width: 80px;">
  <input type="range" id="lonSlider" min="-180" max="180" value="0" step="0.1">
  <span id="lonValue">0°</span>
  <br>
  Time: <input type="range" id="timeSlider" min="0" max="1439" value="720" step="1">
  <span id="timeValue">12:00</span>
  <br>
  Day of Year: <input type="range" id="daySlider" min="1" max="365" value="1" step="1">
  <span id="dayValue">Jan 1</span>
  <br>
  <label><input type="checkbox" id="starfieldToggle" checked> Show Starfield</label>
</div>

<div id="angles">
  <div><span class="angle-label">LST:</span> <span id="lstValue">--</span></div>
  <div><span class="angle-label">MC:</span> <span id="mcValue">--</span></div>
  <div><span class="angle-label">AC:</span> <span id="acValue">--</span></div>
</div>

<div id="sunTimes">
  <div><span class="time-label">☉</span> <span id="sunPositionValue">--</span></div>
  <div><span class="time-label">Sunrise:</span> <span id="sunriseValue">--</span></div>
  <div><span class="time-label">Sunset:</span> <span id="sunsetValue">--</span></div>
</div>

<div id="starInfo">
  <div class="star-name" id="starName">Star Name</div>
  <div class="constellation-name" id="constellationName">Constellation</div>
</div>

<script type='text/javascript' src='./js/ephemeris-1.2.1.bundle.js' charset='utf-8'></script>
<script src="https://cdn.jsdelivr.net/npm/@tarekraafat/autocomplete.js@10.2.9/dist/autoComplete.min.js"></script>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
    "chrono-node": "./node_modules/chrono-node/dist/esm/index.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import * as chrono from 'chrono-node';

// ------------------- DateTimeParser -------------------
class DateTimeParser {
  constructor(inputElement, onDateTimeParsed) {
    this.input = inputElement;
    this.onDateTimeParsed = onDateTimeParsed;
    this.setupEventListeners();
  }

  setupEventListeners() {
    this.input.addEventListener('blur', () => this.parse());
    this.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.parse();
      }
    });
  }

  setNow() {
    const now = new Date();
    this.input.value = 'now';
    this.onDateTimeParsed(now);
    this.showSuccess();
  }

  parse() {
    const text = this.input.value.trim();
    if (!text) return;

    const datetime = this.parseFlexibleDateTime(text);
    if (datetime) {
      this.onDateTimeParsed(datetime);
      this.showSuccess();
    } else {
      this.showError();
    }
  }

  parseFlexibleDateTime(text) {
    // Handle "now" keyword
    if (text.toLowerCase() === 'now') {
      return new Date();
    }

    const customParsed = this.parseCustomFormat(text);
    if (customParsed) return customParsed;

    // Use chrono-node for natural language parsing
    const results = chrono.parse(text);
    if (results.length > 0) {
      return results[0].start.date();
    }

    return null;
  }

  parseCustomFormat(text) {
    const cleanText = text.replace(/\s+/g, '').toLowerCase();

    const pattern1 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})$/;
    const match1 = cleanText.match(pattern1);
    if (match1) {
      const [, month, day, year, hours, minutes] = match1;
      return new Date(year, month - 1, day, hours, minutes, 0);
    }

    const pattern2 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{2})$/;
    const match2 = cleanText.match(pattern2);
    if (match2) {
      const [, month, day, year, hours, minutes, seconds] = match2;
      return new Date(year, month - 1, day, hours, minutes, seconds);
    }

    const pattern3 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(am|pm)$/;
    const match3 = cleanText.match(pattern3);
    if (match3) {
      let [, month, day, year, hours, minutes, ampm] = match3;
      hours = parseInt(hours);
      if (ampm === 'pm' && hours !== 12) hours += 12;
      if (ampm === 'am' && hours === 12) hours = 0;
      return new Date(year, month - 1, day, hours, minutes, 0);
    }

    const pattern4 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{2})(am|pm)$/;
    const match4 = cleanText.match(pattern4);
    if (match4) {
      let [, month, day, year, hours, minutes, seconds, ampm] = match4;
      hours = parseInt(hours);
      if (ampm === 'pm' && hours !== 12) hours += 12;
      if (ampm === 'am' && hours === 12) hours = 0;
      return new Date(year, month - 1, day, hours, minutes, seconds);
    }

    return null;
  }

  showSuccess() {
    this.input.style.borderColor = 'green';
    setTimeout(() => this.input.style.borderColor = '', 1000);
  }

  showError() {
    this.input.style.borderColor = 'red';
    setTimeout(() => this.input.style.borderColor = '', 2000);
  }
}

// ------------------- Scene Setup -------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,2.5,-6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Set camera to look at origin
camera.lookAt(0, 0, 0);

// ------------------- Constants -------------------
const OBLIQUITY = 23.44 * Math.PI/180;
const CE_RADIUS = 3;

// ------------------- Groups -------------------
const celestial = new THREE.Group();
scene.add(celestial);

// ------------------- Fixed Reference Planes (green circles) -------------------
const planeOpts = { side: THREE.DoubleSide, transparent: true, opacity: 0.1 };

// Horizon plane (horizontal)
const horizonPlane = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, ...planeOpts })
);
horizonPlane.rotation.x = -Math.PI/2; // horizontal
scene.add(horizonPlane);

// Horizon outline
const horizonOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  horizonOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const horizonOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(horizonOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
horizonOutline.rotation.x = -Math.PI/2;
scene.add(horizonOutline);

// Compass Rose - Traditional Nautical Style with Half-Filled Points
const compassRosetteGroup = new THREE.Group();

const solidMaterial = new THREE.MeshBasicMaterial({
  color: 0x00ff00,
  transparent: true,
  opacity: 0.2,
  side: THREE.DoubleSide
});

const outlineMaterial = new THREE.LineBasicMaterial({
  color: 0x00ff00,
  opacity: 0.25,
  transparent: true,
  linewidth: 0.5
});

// Create a compass point with one half solid, one half outline
function createSplitCompassPoint(angle, length, width, leftFilled) {
  const group = new THREE.Group();

  // Center point
  const center = new THREE.Vector3(0, 0, 0);
  // Tip of the point
  const tip = new THREE.Vector3(length * Math.sin(angle), 0, length * Math.cos(angle));
  // Left side
  const left = new THREE.Vector3(width * Math.sin(angle - Math.PI/2), 0, width * Math.cos(angle - Math.PI/2));
  // Right side
  const right = new THREE.Vector3(width * Math.sin(angle + Math.PI/2), 0, width * Math.cos(angle + Math.PI/2));

  if (leftFilled) {
    // Left half filled
    const leftShape = new THREE.Shape();
    leftShape.moveTo(0, 0);
    leftShape.lineTo(left.x, left.z);
    leftShape.lineTo(tip.x, tip.z);
    leftShape.lineTo(0, 0);

    const leftGeometry = new THREE.ShapeGeometry(leftShape);
    const leftMesh = new THREE.Mesh(leftGeometry, solidMaterial);
    leftMesh.rotation.x = -Math.PI / 2;
    group.add(leftMesh);

    // Add outline to filled half
    const leftOutlinePoints = [center.clone(), left.clone(), tip.clone(), center.clone()];
    const leftOutlineGeometry = new THREE.BufferGeometry().setFromPoints(leftOutlinePoints);
    const leftOutline = new THREE.Line(leftOutlineGeometry, outlineMaterial);
    group.add(leftOutline);

    // Right half outline only
    const rightPoints = [center.clone(), right.clone(), tip.clone(), center.clone()];
    const rightGeometry = new THREE.BufferGeometry().setFromPoints(rightPoints);
    const rightLine = new THREE.Line(rightGeometry, outlineMaterial);
    group.add(rightLine);
  } else {
    // Right half filled
    const rightShape = new THREE.Shape();
    rightShape.moveTo(0, 0);
    rightShape.lineTo(right.x, right.z);
    rightShape.lineTo(tip.x, tip.z);
    rightShape.lineTo(0, 0);

    const rightGeometry = new THREE.ShapeGeometry(rightShape);
    const rightMesh = new THREE.Mesh(rightGeometry, solidMaterial);
    rightMesh.rotation.x = -Math.PI / 2;
    group.add(rightMesh);

    // Add outline to filled half
    const rightOutlinePoints = [center.clone(), right.clone(), tip.clone(), center.clone()];
    const rightOutlineGeometry = new THREE.BufferGeometry().setFromPoints(rightOutlinePoints);
    const rightOutline = new THREE.Line(rightOutlineGeometry, outlineMaterial);
    group.add(rightOutline);

    // Left half outline only
    const leftPoints = [center.clone(), left.clone(), tip.clone(), center.clone()];
    const leftGeometry = new THREE.BufferGeometry().setFromPoints(leftPoints);
    const leftLine = new THREE.Line(leftGeometry, outlineMaterial);
    group.add(leftLine);
  }

  return group;
}

// All 8 points with alternating left/right fills for pinwheel effect
const allPoints = [
  { angle: 0, length: 1.0, width: 0.12, leftFilled: true },           // North
  { angle: Math.PI/4, length: 0.7, width: 0.10, leftFilled: false },  // NE
  { angle: Math.PI/2, length: 1.0, width: 0.12, leftFilled: true },   // East
  { angle: 3*Math.PI/4, length: 0.7, width: 0.10, leftFilled: false }, // SE
  { angle: Math.PI, length: 1.0, width: 0.12, leftFilled: true },     // South
  { angle: 5*Math.PI/4, length: 0.7, width: 0.10, leftFilled: false }, // SW
  { angle: 3*Math.PI/2, length: 1.0, width: 0.12, leftFilled: true }, // West
  { angle: 7*Math.PI/4, length: 0.7, width: 0.10, leftFilled: false }  // NW
];

allPoints.forEach(point => {
  const pointGroup = createSplitCompassPoint(point.angle, point.length, point.width, point.leftFilled);
  compassRosetteGroup.add(pointGroup);
});

// Position at horizon level
compassRosetteGroup.position.y = 0.01;
scene.add(compassRosetteGroup);

// Meridian outline (no filled plane, only outline)
const meridianOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  meridianOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const meridianOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(meridianOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
meridianOutline.rotation.y = Math.PI/2;
scene.add(meridianOutline);

// Prime vertical outline (no filled plane, only outline)
const pvOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  pvOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const pvOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(pvOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
// No rotation needed - default XY plane is vertical E/W
scene.add(pvOutline);

// ------------------- Celestial Equator -------------------
const ceqPoints = [];
for(let i=0;i<=128;i++){
  const a=(i/128)*Math.PI*2;
  ceqPoints.push(new THREE.Vector3(CE_RADIUS*Math.cos(a), CE_RADIUS*Math.sin(a),0));
}
const ceqOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(ceqPoints),
  new THREE.LineDashedMaterial({color:0x00ffff, opacity:0.6, transparent:true, dashSize:0.5, gapSize:0.3})
);
ceqOutline.computeLineDistances();
// Celestial equator in XY plane (vertical at equator), poles along Z axis
celestial.add(ceqOutline);

// ------------------- Ecliptic -------------------
const ecliptic = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS,128),
  new THREE.MeshBasicMaterial({ color:0x888888, side:THREE.DoubleSide, transparent:true, opacity:0.1 })
);
ecliptic.rotation.x = OBLIQUITY; // Tilt from celestial equator around equinox line
celestial.add(ecliptic);

// ------------------- Zodiac Labels -------------------
const zodiacGroup = new THREE.Group();
zodiacGroup.rotation.x = OBLIQUITY; // Match ecliptic tilt
celestial.add(zodiacGroup);

// Radial lines at 0° of each zodiac sign (every 30°)
const radialLineMaterial = new THREE.LineBasicMaterial({color:0x888888, opacity:0.3, transparent:true});
for(let i=0; i<12; i++){
  // Reverse to match reversed zodiac glyphs
  const angle = THREE.MathUtils.degToRad(-i*30);
  const radialLine = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0,0,0),
      new THREE.Vector3(CE_RADIUS*Math.cos(angle), CE_RADIUS*Math.sin(angle), 0)
    ]),
    radialLineMaterial
  );
  zodiacGroup.add(radialLine);
}

const zodiacRadius = 2.3;
const zodiacGlyphs = Array.from({length:12},(_,i)=>String.fromCodePoint(0x2648+i)+'\uFE0E');

zodiacGlyphs.forEach((glyph,i)=>{
  // Reverse the zodiac order: negate the angle to draw counterclockwise
  const angle = THREE.MathUtils.degToRad(-(i*30+15)); // center at 15° of each sign, reversed
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 84px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(glyph,64,64);
  const texture = new THREE.CanvasTexture(canvas);
  const mat = new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.2,1.2),mat);
  mesh.position.set(zodiacRadius*Math.cos(angle), zodiacRadius*Math.sin(angle),0);
  mesh.rotation.z = angle + Math.PI/2;
  zodiacGroup.add(mesh);
});

// ------------------- Compass Labels -------------------
const compassRadius = 2.5;
function addCompassLabel(text,x,z,rotZ=0){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 64px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text,64,64);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat);
  mesh.position.set(x,0.01,z);
  mesh.rotation.x=-Math.PI/2;
  mesh.rotation.z=rotZ;
  scene.add(mesh);
}
addCompassLabel('N',0,compassRadius,0);
addCompassLabel('S',0,-compassRadius,Math.PI);
addCompassLabel('E',compassRadius,0,-Math.PI/2);
addCompassLabel('W',-compassRadius,0,Math.PI/2);

// ------------------- Celestial Poles -------------------
// Lines extending along polar axis (Z axis in celestial sphere's frame)
const polarLineMaterial = new THREE.LineBasicMaterial({color:0x00ffff, opacity:0.6, transparent:true});
const polarLineLength = 0.67;

const npLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, CE_RADIUS),
    new THREE.Vector3(0, 0, CE_RADIUS + polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(npLine);

const spLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, -CE_RADIUS),
    new THREE.Vector3(0, 0, -CE_RADIUS - polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(spLine);

// Labels at the ends of the polar axis lines
function addPoleLabel(name,z){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=64;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='24px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(name,64,32);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.SpriteMaterial({map:texture, depthTest:false});
  const sprite=new THREE.Sprite(mat);
  sprite.scale.set(1,0.5,1);
  sprite.position.set(0,0,z);
  celestial.add(sprite);
}
addPoleLabel('NP', CE_RADIUS+polarLineLength);
addPoleLabel('SP', -CE_RADIUS-polarLineLength);

// ------------------- Constants for Assets -------------------
const SUN_TEXTURE_PATH = './images/sun_texture.jpg';

// ------------------- Star Map and Constellations -------------------
// Star data: [name, RA (hours), Dec (degrees), magnitude, constellation]
const starData = [
  // Ursa Major (Big Dipper)
  ['Dubhe', 11.062, 61.75, 1.8, 'Ursa Major'],
  ['Merak', 11.031, 56.38, 2.4, 'Ursa Major'],
  ['Phecda', 11.897, 53.69, 2.4, 'Ursa Major'],
  ['Megrez', 12.257, 57.03, 3.3, 'Ursa Major'],
  ['Alioth', 12.900, 55.96, 1.8, 'Ursa Major'],
  ['Mizar', 13.399, 54.93, 2.2, 'Ursa Major'],
  ['Alkaid', 13.792, 49.31, 1.9, 'Ursa Major'],
  // Orion
  ['Betelgeuse', 5.919, 7.41, 0.5, 'Orion'],
  ['Rigel', 5.242, -8.20, 0.1, 'Orion'],
  ['Bellatrix', 5.418, 6.35, 1.6, 'Orion'],
  ['Mintaka', 5.533, -0.30, 2.2, 'Orion'],
  ['Alnilam', 5.603, -1.20, 1.7, 'Orion'],
  ['Alnitak', 5.679, -1.94, 1.8, 'Orion'],
  ['Saiph', 5.796, -9.67, 2.1, 'Orion'],
  // Ursa Minor (Little Dipper)
  ['Polaris', 2.530, 89.26, 2.0, 'Ursa Minor'],
  ['Kochab', 14.845, 74.16, 2.1, 'Ursa Minor'],
  ['Pherkad', 15.345, 71.83, 3.0, 'Ursa Minor'],
  // Cassiopeia
  ['Schedar', 0.675, 56.54, 2.2, 'Cassiopeia'],
  ['Caph', 0.153, 59.15, 2.3, 'Cassiopeia'],
  ['Cih', 0.945, 60.72, 2.5, 'Cassiopeia'],
  ['Ruchbah', 1.430, 60.24, 2.7, 'Cassiopeia'],
  ['Segin', 1.911, 63.67, 3.4, 'Cassiopeia'],
  // Leo
  ['Regulus', 10.139, 11.97, 1.4, 'Leo'],
  ['Denebola', 11.817, 14.57, 2.1, 'Leo'],
  ['Algieba', 10.333, 19.84, 2.6, 'Leo'],
  // Taurus
  ['Aldebaran', 4.599, 16.51, 0.9, 'Taurus'],
  ['Elnath', 5.438, 28.61, 1.7, 'Taurus'],
  // Gemini
  ['Pollux', 7.755, 28.03, 1.2, 'Gemini'],
  ['Castor', 7.577, 31.89, 1.6, 'Gemini'],
  // Canis Major
  ['Sirius', 6.752, -16.72, -1.5, 'Canis Major'],
  ['Adhara', 6.977, -28.97, 1.5, 'Canis Major'],
  // Boötes
  ['Arcturus', 14.261, 19.18, -0.05, 'Boötes'],
  // Virgo
  ['Spica', 13.420, -11.16, 1.0, 'Virgo'],
  // Lyra
  ['Vega', 18.615, 38.78, 0.0, 'Lyra'],
  // Aquila
  ['Altair', 19.846, 8.87, 0.8, 'Aquila'],
  // Cygnus
  ['Deneb', 20.690, 45.28, 1.3, 'Cygnus'],
  ['Albireo', 19.512, 27.96, 3.1, 'Cygnus'],
  // Scorpius
  ['Antares', 16.490, -26.43, 1.1, 'Scorpius'],
  // Crux (Southern Cross)
  ['Acrux', 12.443, -63.10, 0.8, 'Crux'],
  ['Mimosa', 12.795, -59.69, 1.3, 'Crux'],
  ['Gacrux', 12.519, -57.11, 1.6, 'Crux'],
  // Centaurus
  ['Alpha Centauri', 14.661, -60.84, -0.3, 'Centaurus'],
  ['Beta Centauri', 14.064, -60.37, 0.6, 'Centaurus'],
  // Eridanus
  ['Achernar', 1.629, -57.24, 0.5, 'Eridanus'],
  // Carina
  ['Canopus', 6.399, -52.70, -0.7, 'Carina']
];

// Constellation line connections: [star1_name, star2_name]
const constellationLines = [
  // Big Dipper
  ['Dubhe', 'Merak'],
  ['Merak', 'Phecda'],
  ['Phecda', 'Megrez'],
  ['Megrez', 'Alioth'],
  ['Alioth', 'Mizar'],
  ['Mizar', 'Alkaid'],
  ['Megrez', 'Dubhe'],
  // Little Dipper
  ['Polaris', 'Kochab'],
  ['Kochab', 'Pherkad'],
  // Orion
  ['Betelgeuse', 'Bellatrix'],
  ['Bellatrix', 'Mintaka'],
  ['Mintaka', 'Alnilam'],
  ['Alnilam', 'Alnitak'],
  ['Alnitak', 'Saiph'],
  ['Saiph', 'Rigel'],
  ['Rigel', 'Betelgeuse'],
  ['Betelgeuse', 'Mintaka'],
  ['Alnilam', 'Rigel'],
  // Cassiopeia (W shape)
  ['Caph', 'Schedar'],
  ['Schedar', 'Cih'],
  ['Cih', 'Ruchbah'],
  ['Ruchbah', 'Segin'],
  // Leo (simplified)
  ['Regulus', 'Algieba'],
  ['Regulus', 'Denebola'],
  // Gemini
  ['Castor', 'Pollux'],
  // Summer Triangle
  ['Vega', 'Altair'],
  ['Altair', 'Deneb'],
  ['Deneb', 'Vega'],
  // Cygnus (Northern Cross)
  ['Deneb', 'Albireo'],
  // Southern Cross
  ['Acrux', 'Gacrux'],
  ['Mimosa', 'Gacrux']
];

// Convert RA/Dec to cartesian coordinates on celestial sphere
function raDecToVector3(ra_hours, dec_deg, radius) {
  // RA: 0-24 hours, convert to radians (0-2π)
  // Dec: -90 to +90 degrees
  const ra = (ra_hours / 24) * Math.PI * 2;
  const dec = THREE.MathUtils.degToRad(dec_deg);

  // Spherical to Cartesian conversion
  // In celestial coordinates: RA is angle in equatorial plane, Dec is elevation
  // X-Y plane is celestial equator, Z is towards north celestial pole
  const x = radius * Math.cos(dec) * Math.cos(ra);
  const y = radius * Math.cos(dec) * Math.sin(ra);
  const z = radius * Math.sin(dec);

  return new THREE.Vector3(x, y, z);
}

// Create star field
const starGroup = new THREE.Group();
const starMeshes = {};

starData.forEach(([name, ra, dec, mag, constellation]) => {
  // Star size based on magnitude (brighter = larger)
  // Magnitude scale is inverted (smaller number = brighter)
  const size = Math.max(0.015, 0.05 - mag * 0.01); // Smaller base size

  // Star brightness based on magnitude
  const brightness = Math.max(0.3, 1.0 - mag * 0.15);

  // Create star sphere (smaller)
  const starGeometry = new THREE.SphereGeometry(size, 8, 8);
  const starMaterial = new THREE.MeshBasicMaterial({
    color: new THREE.Color(brightness, brightness, brightness * 0.95)
  });

  const star = new THREE.Mesh(starGeometry, starMaterial);
  const position = raDecToVector3(ra, dec, CE_RADIUS * 3.0);
  star.position.copy(position);

  // Store star data for click detection
  star.userData = { name, constellation };

  starGroup.add(star);
  starMeshes[name] = star;

  // Add multiple glow layers for radiant effect (similar to sun)
  // Base opacity on magnitude - brighter stars get more intense glows
  const baseGlowOpacity = Math.max(0.15, 0.5 - mag * 0.06);

  const starGlowLayers = [
    { size: size * 1.5, opacity: baseGlowOpacity * 0.9, color: new THREE.Color(brightness, brightness, brightness * 0.98) },
    { size: size * 2.5, opacity: baseGlowOpacity * 0.6, color: new THREE.Color(brightness * 0.95, brightness * 0.95, brightness * 0.9) },
    { size: size * 4.0, opacity: baseGlowOpacity * 0.4, color: new THREE.Color(brightness * 0.9, brightness * 0.9, brightness * 0.85) },
    { size: size * 6.0, opacity: baseGlowOpacity * 0.2, color: new THREE.Color(brightness * 0.85, brightness * 0.85, brightness * 0.8) }
  ];

  starGlowLayers.forEach((layer, index) => {
    const glowGeometry = new THREE.SphereGeometry(layer.size, 16, 16);
    const glowMaterial = new THREE.MeshBasicMaterial({
      color: layer.color,
      transparent: true,
      opacity: layer.opacity,
      blending: THREE.AdditiveBlending
    });

    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    glow.position.copy(position);

    // Store same data on glow so hovering over any layer works
    glow.userData = { name, constellation };

    starGroup.add(glow);
  });
});

// Add constellation lines
const constellationLineGroup = new THREE.Group();
const lineMaterial = new THREE.LineBasicMaterial({
  color: 0x4444ff,
  transparent: true,
  opacity: 0.4
});

constellationLines.forEach(([star1, star2]) => {
  if (starMeshes[star1] && starMeshes[star2]) {
    const points = [
      starMeshes[star1].position.clone(),
      starMeshes[star2].position.clone()
    ];
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    constellationLineGroup.add(line);
  }
});

// Add star field and constellation lines to celestial sphere
celestial.add(starGroup);
celestial.add(constellationLineGroup);

// Add background star field (smaller, dimmer stars for atmosphere)
const bgStarCount = 800;
const bgStarGeometry = new THREE.BufferGeometry();
const bgStarPositions = [];
const bgStarColors = [];

for (let i = 0; i < bgStarCount; i++) {
  // Random position on sphere
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  const r = CE_RADIUS * 2.9;

  const x = r * Math.sin(phi) * Math.cos(theta);
  const y = r * Math.sin(phi) * Math.sin(theta);
  const z = r * Math.cos(phi);

  bgStarPositions.push(x, y, z);

  // Vary brightness
  const brightness = 0.3 + Math.random() * 0.5;
  bgStarColors.push(brightness, brightness, brightness * 0.98);
}

bgStarGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bgStarPositions, 3));
bgStarGeometry.setAttribute('color', new THREE.Float32BufferAttribute(bgStarColors, 3));

const bgStarMaterial = new THREE.PointsMaterial({
  size: 0.03,
  vertexColors: true,
  transparent: true,
  opacity: 0.8
});

const bgStarField = new THREE.Points(bgStarGeometry, bgStarMaterial);
celestial.add(bgStarField);

// ------------------- Sun on Ecliptic (marker) -------------------
// Load sun texture (shared for both ecliptic marker and distant sun)
const textureLoader = new THREE.TextureLoader();
// console.log('Attempting to load sun texture from:', SUN_TEXTURE_PATH);
const sunTextureEcliptic = textureLoader.load(
  SUN_TEXTURE_PATH,
  // (texture) => {
  //   console.log('✓ Sun texture loaded successfully!', texture);
  // },
  // (progress) => {
  //   console.log('Loading sun texture:', (progress.loaded / progress.total * 100).toFixed(0) + '%');
  // },
  // (error) => {
  //   console.error('✗ Failed to load sun texture:', error);
  //   console.error('Path attempted:', SUN_TEXTURE_PATH);
  // }
);

const eclipticSunRadius = 0.15;

const sun = new THREE.Mesh(
  new THREE.SphereGeometry(eclipticSunRadius, 32, 32),
  new THREE.MeshBasicMaterial({
    map: sunTextureEcliptic,
    color: 0xffaa44 // Orange tint for more realistic sun color
  })
);

// Add glow layers for ecliptic sun (similar to distant sun but scaled)
const eclipticSunGlowLayers = [
  { size: eclipticSunRadius * 1.15, opacity: 0.1, color: 0xffff99 },  // Inner corona
  { size: eclipticSunRadius * 1.4, opacity: 0.1, color: 0xffcc66 },   // Middle corona
  // { size: eclipticSunRadius * 2.0, opacity: 0.05, color: 0xff9933 },   // Outer corona
  // { size: eclipticSunRadius * 3.0, opacity: 0.05, color: 0xff6600 }   // Extended corona
];

const eclipticSunGroup = new THREE.Group();
eclipticSunGroup.add(sun);

eclipticSunGlowLayers.forEach(layer => {
  const glowMesh = new THREE.Mesh(
    new THREE.SphereGeometry(layer.size, 32, 32),
    new THREE.MeshBasicMaterial({
      color: layer.color,
      transparent: true,
      opacity: layer.opacity,
      blending: THREE.AdditiveBlending
    })
  );
  eclipticSunGroup.add(glowMesh);
});

zodiacGroup.add(eclipticSunGroup); // Add to zodiacGroup so it's on the ecliptic plane

// ------------------- Realistic Sun (far out in space) -------------------
// Astronomical constants for realistic proportions:
// - Sun's actual diameter: 1,392,700 km
// - Sun's actual distance from Earth: 149,597,870 km (1 AU)
// - Angular diameter of sun as seen from Earth: ~0.53 degrees (0.00925 radians)
//
// For our celestial sphere (radius = CE_RADIUS = 3 units):
// - This represents the celestial sphere, which is effectively infinite distance
// - The sun should appear to subtend 0.53 degrees from Earth (center of scene)
// - Using angular size: apparent_size = 2 * distance * tan(angular_diameter/2)

const sunAngularDiameter = 0.53 * Math.PI / 180; // 0.53 degrees in radians
const sunDistance = CE_RADIUS * 50; // Place sun far beyond celestial sphere

// Calculate sun's radius based on its angular size from the observer's perspective
// apparent_diameter = 2 * distance * tan(angular_diameter / 2)
const realisticSunRadius = sunDistance * Math.tan(sunAngularDiameter / 2);

// Reuse the same texture for distant sun (already loaded above)
const sunTexture = sunTextureEcliptic;

const realisticSun = new THREE.Mesh(
  new THREE.SphereGeometry(realisticSunRadius, 64, 64),
  new THREE.MeshBasicMaterial({
    // map: sunTexture,
    color: 0xffaa44 // Orange tint for more realistic sun color
  })
);

// Add intense glow layers for the realistic sun (corona extends beyond visible surface)
const sunGlowLayers = [
  { size: realisticSunRadius * 1.15, opacity: 0.7, color: 0xffff99 },  // Inner corona
  { size: realisticSunRadius * 1.4, opacity: 0.5, color: 0xffcc66 },   // Middle corona
  { size: realisticSunRadius * 2.0, opacity: 0.3, color: 0xff9933 },   // Outer corona
  { size: realisticSunRadius * 3.0, opacity: 0.15, color: 0xff6600 }   // Extended corona
];

const realisticSunGroup = new THREE.Group();
realisticSunGroup.add(realisticSun);

sunGlowLayers.forEach(layer => {
  const glowMesh = new THREE.Mesh(
    new THREE.SphereGeometry(layer.size, 32, 32),
    new THREE.MeshBasicMaterial({
      color: layer.color,
      transparent: true,
      opacity: layer.opacity,
      blending: THREE.AdditiveBlending
    })
  );
  realisticSunGroup.add(glowMesh);
});

// Position will be updated in updateSphere() to match sun's ecliptic position
zodiacGroup.add(realisticSunGroup);

// ------------------- Sliders -------------------
let currentLatitude=0;
let currentLongitude=0;
let currentTime=720;
let currentDay=1;
let currentYear=2000;

const latSlider=document.getElementById('latSlider');
const latValue=document.getElementById('latValue');
const lonSlider=document.getElementById('lonSlider');
const lonValue=document.getElementById('lonValue');
const timeSlider=document.getElementById('timeSlider');
const timeValue=document.getElementById('timeValue');
const daySlider=document.getElementById('daySlider');
const dayValue=document.getElementById('dayValue');

function dayToStr(day, year){
  const md=[31,29,31,30,31,30,31,31,30,31,30,31];
  const mn=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  let d=day;
  for(let i=0;i<12;i++){
    if(d<=md[i]) return `${mn[i]} ${d}, ${year}`;
    d-=md[i];
  }
  return `Dec 31, ${year}`;
}

// ------------------- Celestial Sphere Update -------------------
function updateSphere(){
  const latRad = THREE.MathUtils.degToRad(currentLatitude);

  // Calculate Local Sidereal Time first (needed for celestial rotation)
  const J2000_epoch = 2451545.0;

  // Adjust time for longitude: 15° longitude = 1 hour time difference
  const longitudeTimeOffset = (currentLongitude / 15) * 60; // Convert to minutes
  const localTime = currentTime + longitudeTimeOffset;

  // Calculate Julian Date for the actual year
  // Formula: JD = 367*Y - INT(7*(Y+INT((M+9)/12))/4) + INT(275*M/9) + D + 1721013.5 + UT/24
  const Y = currentYear;
  const M = Math.floor((currentDay - 1) / 30) + 1; // Rough approximation
  const D = ((currentDay - 1) % 30) + 1;
  const UT = localTime / 60; // Convert minutes to hours

  // Simplified: Use year offset from J2000
  const yearOffset = (currentYear - 2000) * 365.25;
  const daysFromJ2000 = yearOffset + (currentDay - 1) + (localTime / 1440);
  const julianDate = 2451544.5 + daysFromJ2000;

  // Greenwich Sidereal Time at 0h UT (simplified formula)
  const T = (julianDate - J2000_epoch) / 36525;
  const GST0 = 280.46061837 + 360.98564736629 * (julianDate - J2000_epoch) + 0.000387933 * T * T;

  // Local Sidereal Time = GST + longitude (in degrees)
  let LST = (GST0 + currentLongitude + (localTime / 1440) * 360) % 360;
  if (LST < 0) LST += 360;

  // Rotate celestial sphere based on LST (sidereal time, not solar time!)
  const lstAngle = THREE.MathUtils.degToRad(LST);

  // Set rotation order: X rotation (latitude tilt) then Z rotation (sidereal time)
  celestial.rotation.order = 'XZY';
  celestial.rotation.x = -latRad; // Tilt polar axis from north (Z) towards zenith (Y)
  celestial.rotation.z = lstAngle; // Rotate based on Local Sidereal Time
  celestial.rotation.y = 0;

  // Sun position - Convert day of year to month/day
  let sunLonRad;
  let sunBodyData = null; // Save for rise/set calculation

  // Convert day of year (1-365) to month and day
  const monthDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 2000 is leap year
  let remainingDays = currentDay;
  let month = 0;
  let day = 1;
  for (let i = 0; i < 12; i++) {
    if (remainingDays <= monthDays[i]) {
      month = i;
      day = remainingDays;
      break;
    }
    remainingDays -= monthDays[i];
  }

  // Convert time (minutes since midnight) to hours/minutes
  const hours = Math.floor(currentTime / 60);
  const minutes = currentTime % 60;

  // Use ephemeris if available, otherwise fall back to approximation
  if (typeof $moshier !== 'undefined') {
    try {
      // Set observer location
      $const.tlong = currentLongitude;  // Observer longitude
      $const.glat = currentLatitude;  // Observer latitude

      // Set date
      const date = {
        year: currentYear,
        month: month + 1,  // Moshier uses 1-12, not 0-11
        day: day,
        hours: hours,
        minutes: minutes,
        seconds: 0
      };

      // Initialize and calculate position
      $processor.init();
      const body = $moshier.body.sun;
      $processor.calc(date, body);

      // Calculate rise and set times
      // Note: riset needs to be called separately and uses a date at the start of the day
      const dateForRiset = {
        year: currentYear,
        month: month + 1,
        day: day,
        hours: 0,
        minutes: 0,
        seconds: 0
      };

      // Note: Ephemeris rise/set not used - we calculate from scratch below

      sunBodyData = body; // Save for later use (now includes rise/set if available)

      // Get Sun's ecliptic longitude from the result
      // The ecliptic longitude should be in body.position.rect or body.position.polar
      // Moshier returns longitude in radians in body.position.longitude or similar
      if (body.position && body.position.apparentLongitude !== undefined) {
        sunLonRad = THREE.MathUtils.degToRad(body.position.apparentLongitude);
      } else if (body.position && body.position.polar) {
        sunLonRad = THREE.MathUtils.degToRad(body.position.polar[0]);
      } else {
        // Fallback to approximation if structure is unexpected
        console.warn('Unexpected ephemeris data structure, using approximation');
        const sunLon = (280 + (currentDay-1)*(360/365))%360;
        sunLonRad = THREE.MathUtils.degToRad(sunLon);
      }
    } catch (e) {
      console.warn('Ephemeris calculation failed, using approximation:', e);
      // Fallback to approximation
      const sunLon = (280 + (currentDay-1)*(360/365))%360;
      sunLonRad = THREE.MathUtils.degToRad(sunLon);
    }
  } else {
    // Simple approximation for year 2000
    const sunLon = (280 + (currentDay-1)*(360/365))%360;
    sunLonRad = THREE.MathUtils.degToRad(sunLon);
  }

  // Position Sun on ecliptic (in zodiacGroup's coordinate system)
  // Offset slightly above ecliptic plane (positive Z) to avoid being blocked by ecliptic fill
  // Negate angle to match reversed zodiac drawing
  eclipticSunGroup.position.set(CE_RADIUS*Math.cos(-sunLonRad), CE_RADIUS*Math.sin(-sunLonRad), 0.05);

  // Position realistic sun far out in space at same ecliptic angle
  const sunDistanceFromEarth = CE_RADIUS * 50;
  realisticSunGroup.position.set(
    sunDistanceFromEarth * Math.cos(-sunLonRad),
    sunDistanceFromEarth * Math.sin(-sunLonRad),
    0
  );

  // Convert sun's ecliptic longitude to degrees and display
  const sunLonDeg = THREE.MathUtils.radToDeg(sunLonRad);
  const sunLonNormalized = ((sunLonDeg % 360) + 360) % 360; // Normalize to 0-360
  document.getElementById('sunPositionValue').textContent = toZodiacString(sunLonNormalized);

  // ------------------- Calculate Astrological Angles (MC, IC, AC, DSC) -------------------
  // Using traditional astrological formulas (not geometric intersections)
  //
  // MC (Midheaven): Ecliptic degree where RA = LST (equatorial meridian)
  // AC (Ascendant): Ecliptic degree rising on eastern horizon

  const epsilon = OBLIQUITY;
  const lstRad = THREE.MathUtils.degToRad(LST);

  // MC Formula: tan(MC) = tan(RAMC) / cos(ε), where RAMC = LST
  // Derivation: Convert equatorial coordinates (RA=LST, Dec=0) to ecliptic longitude
  let MC = THREE.MathUtils.radToDeg(
    Math.atan2(Math.sin(lstRad), Math.cos(lstRad) * Math.cos(epsilon))
  );
  if (MC < 0) MC += 360;

  // IC: Opposite point (180° from MC) - lower meridian
  let IC = (MC + 180) % 360;

  // AC (Ascendant): Where ecliptic intersects the eastern horizon
  // Formula: tan(AC) = -cos(RAMC) / (sin(RAMC)*cos(ε) + tan(lat)*sin(ε))
  // where RAMC = LST (Right Ascension of Midheaven)
  const tanLat = Math.tan(latRad);
  let DSC = THREE.MathUtils.radToDeg(
    Math.atan2(-Math.cos(lstRad), Math.sin(lstRad) * Math.cos(epsilon) + tanLat * Math.sin(epsilon))
  );
  if (DSC < 0) DSC += 360;

  // AC: Opposite point (180° from DSC)
  let AC = (DSC + 180) % 360;

  // Convert to zodiac notation (sign + degree)
  function toZodiacString(longitude) {
    const signs = ['♈\uFE0E', '♉\uFE0E', '♊\uFE0E', '♋\uFE0E', '♌\uFE0E', '♍\uFE0E', '♎\uFE0E', '♏\uFE0E', '♐\uFE0E', '♑\uFE0E', '♒\uFE0E', '♓\uFE0E'];
    let signIndex = Math.floor(longitude / 30);
    let degree = longitude % 30;
    let wholeDegs = Math.floor(degree);
    let decimalMinutes = (degree % 1) * 60;
    let minutes = Math.floor(decimalMinutes);
    let seconds = (decimalMinutes % 1) * 60;

    // Round up if seconds >= 30
    if (seconds >= 30) {
      minutes++;
      if (minutes >= 60) {
        minutes = 0;
        wholeDegs++;
        if (wholeDegs >= 30) {
          wholeDegs = 0;
          signIndex = (signIndex + 1) % 12;
        }
      }
    }

    return `${wholeDegs.toString().padStart(2, '0')}${signs[signIndex]}${minutes.toString().padStart(2, '0')}`;
  }

  function lstToTimeString(lst) {
    const hours = Math.floor(lst / 15);
    const minutes = Math.floor((lst % 15) * 4);
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }

  // Validation: Verify calculations match expected values
  // Set to true to enable verification logging
  const verifyAngles = false;
  if (verifyAngles) {
    console.log('=== Astrological Angles ===');
    console.log('Location: Lat', currentLatitude.toFixed(2), '° | Lon', currentLongitude.toFixed(2), '°');
    console.log('LST:', LST.toFixed(2), '° (', lstToTimeString(LST), ')');
    console.log('MC:', MC.toFixed(2), '° =', toZodiacString(MC));
    console.log('IC:', IC.toFixed(2), '° =', toZodiacString(IC));
    console.log('AC:', AC.toFixed(2), '° =', toZodiacString(AC));
    console.log('DSC:', DSC.toFixed(2), '° =', toZodiacString(DSC));
  }

  // Update display
  document.getElementById('lstValue').textContent = lstToTimeString(LST);
  document.getElementById('mcValue').textContent = toZodiacString(MC);
  document.getElementById('acValue').textContent = toZodiacString(AC);

  // Use the calculated angles for sphere placement
  const mcRad_ecliptic = THREE.MathUtils.degToRad(MC);
  const icRad_ecliptic = THREE.MathUtils.degToRad(IC);
  const acRad_ecliptic = THREE.MathUtils.degToRad(AC);
  const dscRad_ecliptic = THREE.MathUtils.degToRad(DSC);

  // Position spheres directly on the ecliptic in zodiacGroup's local coordinate system
  // The spheres are now children of zodiacGroup, so they rotate with the ecliptic
  // Position them at their ecliptic longitudes in the XY plane (before obliquity tilt)
  // Negate angles to match reversed zodiac glyph drawing
  spheres["MC"].position.set(CE_RADIUS * Math.cos(-mcRad_ecliptic), CE_RADIUS * Math.sin(-mcRad_ecliptic), 0.05);
  spheres["IC"].position.set(CE_RADIUS * Math.cos(-icRad_ecliptic), CE_RADIUS * Math.sin(-icRad_ecliptic), 0.05);
  spheres["ASC"].position.set(CE_RADIUS * Math.cos(-acRad_ecliptic), CE_RADIUS * Math.sin(-acRad_ecliptic), 0.05);
  spheres["DSC"].position.set(CE_RADIUS * Math.cos(-dscRad_ecliptic), CE_RADIUS * Math.sin(-dscRad_ecliptic), 0.05);

  // Rotate the zodiac wheel (with spheres) so AC sphere is on eastern horizon
  //
  // The zodiac glyphs and spheres are now drawn in reverse order (negative angles).
  // The AC sphere is at angle -acRad_ecliptic in the zodiac's local XY plane.
  //
  // To position AC at eastern horizon:
  // - AC is at -acRad_ecliptic
  // - Rotate by +acRad_ecliptic to bring it to 0 (eastern horizon)
  // - Add LST rotation for primary motion
  //
  // But wait - the celestial group already rotates by lstAngle, which the zodiac inherits
  // We need to counter-rotate and then position correctly:
  zodiacGroup.rotation.z = -lstAngle + acRad_ecliptic;

  // Update angle labels to follow sphere positions
  // Get world positions since spheres are now children of zodiacGroup
  if (window.angleLabels) {
    const mcWorldPos = new THREE.Vector3();
    spheres["MC"].getWorldPosition(mcWorldPos);
    window.angleLabels.MC.position.copy(mcWorldPos);
    window.angleLabels.MC.position.y += 0.3; // Offset above sphere

    const icWorldPos = new THREE.Vector3();
    spheres["IC"].getWorldPosition(icWorldPos);
    window.angleLabels.IC.position.copy(icWorldPos);
    window.angleLabels.IC.position.y -= 0.3; // Offset below sphere

    const ascWorldPos = new THREE.Vector3();
    spheres["ASC"].getWorldPosition(ascWorldPos);
    window.angleLabels.ASC.position.copy(ascWorldPos);
    window.angleLabels.ASC.position.x += 0.3; // Offset to the right

    const dscWorldPos = new THREE.Vector3();
    spheres["DSC"].getWorldPosition(dscWorldPos);
    window.angleLabels.DSC.position.copy(dscWorldPos);
    window.angleLabels.DSC.position.x -= 0.3; // Offset to the left
  }

  // Verify positioning (can be disabled after verification)
  const verifyPositions = true;
  if (verifyPositions) {
    console.log('=== Ecliptic Intersection Angles ===');
    console.log('MC (ecliptic ∩ meridian):', MC.toFixed(2), '° =', toZodiacString(MC));
    console.log('AC (ecliptic ∩ horizon):', AC.toFixed(2), '° =', toZodiacString(AC));
    console.log('');
    console.log('Sphere positions:');
    console.log('MC position:', spheres["MC"].position.x.toFixed(4), spheres["MC"].position.y.toFixed(4), spheres["MC"].position.z.toFixed(4));
    console.log('IC position:', spheres["IC"].position.x.toFixed(4), spheres["IC"].position.y.toFixed(4), spheres["IC"].position.z.toFixed(4));
    console.log('ASC position:', spheres["ASC"].position.x.toFixed(4), spheres["ASC"].position.y.toFixed(4), spheres["ASC"].position.z.toFixed(4));
    console.log('DSC position:', spheres["DSC"].position.x.toFixed(4), spheres["DSC"].position.y.toFixed(4), spheres["DSC"].position.z.toFixed(4));
    console.log('MC on meridian (X ≈ 0):', spheres["MC"].position.x.toFixed(4));
    console.log('ASC on horizon (Y ≈ 0):', spheres["ASC"].position.y.toFixed(4));
  }

  // ------------------- Calculate Sunrise and Sunset (from scratch) -------------------
  // Calculate rise/set times based on sun's ecliptic longitude
  // Algorithm: Convert ecliptic to equatorial, calculate hour angle, find rise/set times

  function calculateRiseSet(sunEclipticLon, latitude, longitude, dayOfYear) {
    // Constants
    const OBLIQUITY_RAD = epsilon;
    const SUN_ANGULAR_RADIUS = 0.267 * Math.PI / 180; // 16 arcminutes
    const ATMOSPHERIC_REFRACTION = 0.567 * Math.PI / 180; // 34 arcminutes
    const ALTITUDE_AT_RISE_SET = -(SUN_ANGULAR_RADIUS + ATMOSPHERIC_REFRACTION); // -0.833 degrees

    // Convert ecliptic longitude to equatorial coordinates (RA, Dec)
    // For the sun, ecliptic latitude β ≈ 0
    const sinDec = Math.sin(OBLIQUITY_RAD) * Math.sin(sunEclipticLon);
    const declination = Math.asin(sinDec);

    const rightAscension = Math.atan2(
      Math.sin(sunEclipticLon) * Math.cos(OBLIQUITY_RAD),
      Math.cos(sunEclipticLon)
    );
    const RA_deg = THREE.MathUtils.radToDeg(rightAscension);
    const RA_norm = RA_deg < 0 ? RA_deg + 360 : RA_deg;

    // Calculate hour angle when sun is at horizon
    const latRad = THREE.MathUtils.degToRad(latitude);
    const cosHourAngle = (Math.sin(ALTITUDE_AT_RISE_SET) - Math.sin(latRad) * Math.sin(declination)) /
                         (Math.cos(latRad) * Math.cos(declination));

    // Check for no sunrise/sunset (polar regions)
    if (cosHourAngle > 1) {
      return { sunrise: "No sunrise", sunset: "No sunset", transit: "--:--" };
    }
    if (cosHourAngle < -1) {
      return { sunrise: "24h sun", sunset: "24h sun", transit: "--:--" };
    }

    // Hour angle in degrees (0-180)
    const H_deg = THREE.MathUtils.radToDeg(Math.acos(cosHourAngle));

    // Calculate Greenwich Sidereal Time at 0h UT for this day
    const julianDate0h = 2451544.5 + (dayOfYear - 1); // JD for year 2000
    const T = (julianDate0h - J2000_epoch) / 36525;
    const GST0 = 280.46061837 + 360.98564736629 * (julianDate0h - J2000_epoch) +
                 0.000387933 * T * T - 0.0000000258 * T * T * T;

    // Calculate transit time (when RA = LST)
    // LST = GST + longitude, so at transit: GST = RA - longitude
    // Time in UT when this occurs: (RA - longitude - GST0) / 360.98564736629 * 24 hours
    let transitUT = ((RA_norm - longitude - GST0) / 360.98564736629) * 24; // hours

    // Normalize to 0-24 range
    while (transitUT < 0) transitUT += 24;
    while (transitUT >= 24) transitUT -= 24;

    // Sunrise and sunset times (UT)
    const H_hours = H_deg / 15; // Convert hour angle from degrees to hours
    let sunriseUT = transitUT - H_hours;
    let sunsetUT = transitUT + H_hours;

    // Normalize to 0-24 range
    while (sunriseUT < 0) sunriseUT += 24;
    while (sunriseUT >= 24) sunriseUT -= 24;
    while (sunsetUT < 0) sunsetUT += 24;
    while (sunsetUT >= 24) sunsetUT -= 24;

    // Convert from UT to local solar time (add longitude offset)
    const lonTimeOffset = longitude / 15; // hours
    let sunriseLocal = sunriseUT + lonTimeOffset;
    let sunsetLocal = sunsetUT + lonTimeOffset;
    let transitLocal = transitUT + lonTimeOffset;

    // Normalize to 0-24 range
    while (sunriseLocal < 0) sunriseLocal += 24;
    while (sunriseLocal >= 24) sunriseLocal -= 24;
    while (sunsetLocal < 0) sunsetLocal += 24;
    while (sunsetLocal >= 24) sunsetLocal -= 24;
    while (transitLocal < 0) transitLocal += 24;
    while (transitLocal >= 24) transitLocal -= 24;

    // Format as HH:MM
    const formatTime = (hours) => {
      const h = Math.floor(hours);
      const m = Math.floor((hours - h) * 60);
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
    };

    return {
      sunrise: formatTime(sunriseLocal),
      sunset: formatTime(sunsetLocal),
      transit: formatTime(transitLocal)
    };
  }

  // Calculate sunrise/sunset using our from-scratch implementation
  const riseSetData = calculateRiseSet(sunLonRad, currentLatitude, currentLongitude, currentDay);

  document.getElementById('sunriseValue').textContent = riseSetData.sunrise;
  document.getElementById('sunsetValue').textContent = riseSetData.sunset;
}

// ------------------- Angle Spheres -------------------
const spheres={};
function addAngle(name,color){
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(0.12,16,16),
    new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.6})
  );
  zodiacGroup.add(mesh); // Add to zodiacGroup so they rotate with the ecliptic
  spheres[name]=mesh;
}
addAngle("MC",0x888888);
addAngle("IC",0x888888);
addAngle("ASC",0x888888);
addAngle("DSC",0x888888);

// ------------------- Angle Labels -------------------
function addAngleLabel(name) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.font = 'bold 32px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(name, 64, 32);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
  const sprite = new THREE.Sprite(material);
  sprite.scale.set(0.8, 0.4, 1);
  scene.add(sprite);
  return sprite;
}

window.angleLabels = {
  MC: addAngleLabel('MC'),
  IC: addAngleLabel('IC'),
  ASC: addAngleLabel('ASC'),
  DSC: addAngleLabel('DSC')
};

// ------------------- Lat/Lon Text Input Elements -------------------
const latInput=document.getElementById('latInput');
const lonInput=document.getElementById('lonInput');

// ------------------- Slider Listeners -------------------
latSlider.addEventListener('input',()=>{
  currentLatitude=parseFloat(latSlider.value);
  latValue.textContent=currentLatitude.toFixed(1)+"°";
  latInput.value=currentLatitude.toFixed(4);
  updateSphere();
});

lonSlider.addEventListener('input',()=>{
  currentLongitude=parseFloat(lonSlider.value);
  lonValue.textContent=currentLongitude.toFixed(1)+"°";
  lonInput.value=currentLongitude.toFixed(4);
  updateSphere();
});

timeSlider.addEventListener('input',()=>{
  currentTime=parseFloat(timeSlider.value);
  let h=Math.floor(currentTime/60);
  let m=currentTime%60;
  timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
  // Update day display to show decimal JD
  const jd = currentDay + (currentTime / 1440);
  dayValue.textContent=`Day ${jd.toFixed(4)}: ${dayToStr(currentDay, currentYear)}`;
  updateSphere();
});
daySlider.addEventListener('input',()=>{
  currentDay=parseFloat(daySlider.value);
  const jd = currentDay + (currentTime / 1440); // Add fractional day from time
  dayValue.textContent=`Day ${jd.toFixed(4)}: ${dayToStr(currentDay, currentYear)}`;
  updateSphere();
});

// ------------------- Lat/Lon Text Input Listeners -------------------
function parseLatInput() {
  const value = parseFloat(latInput.value);
  if (!isNaN(value)) {
    // Clamp to valid range
    const clamped = Math.max(-66, Math.min(66, value));
    currentLatitude = clamped;
    latSlider.value = clamped;
    latValue.textContent = clamped.toFixed(1) + "°";
    latInput.value = clamped.toFixed(4);
    latInput.style.borderColor = 'green';
    setTimeout(() => latInput.style.borderColor = '', 1000);
    updateSphere();
  } else {
    latInput.style.borderColor = 'red';
    setTimeout(() => latInput.style.borderColor = '', 2000);
  }
}

function parseLonInput() {
  const value = parseFloat(lonInput.value);
  if (!isNaN(value)) {
    // Clamp to valid range
    const clamped = Math.max(-180, Math.min(180, value));
    currentLongitude = clamped;
    lonSlider.value = clamped;
    lonValue.textContent = clamped.toFixed(1) + "°";
    lonInput.value = clamped.toFixed(4);
    lonInput.style.borderColor = 'green';
    setTimeout(() => lonInput.style.borderColor = '', 1000);
    updateSphere();
  } else {
    lonInput.style.borderColor = 'red';
    setTimeout(() => lonInput.style.borderColor = '', 2000);
  }
}

latInput.addEventListener('blur', parseLatInput);
latInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    parseLatInput();
  }
});

lonInput.addEventListener('blur', parseLonInput);
lonInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    parseLonInput();
  }
});

// ------------------- Starfield Toggle -------------------
const starfieldToggle = document.getElementById('starfieldToggle');
starfieldToggle.addEventListener('change', () => {
  const visible = starfieldToggle.checked;
  starGroup.visible = visible;
  constellationLineGroup.visible = visible;
  bgStarField.visible = visible;
});

// ------------------- Animate -------------------
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}

currentLatitude=parseFloat(latSlider.value);
currentLongitude=parseFloat(lonSlider.value);
currentTime=parseFloat(timeSlider.value);
currentDay=parseFloat(daySlider.value);
currentYear=2000; // Default year
latValue.textContent=currentLatitude.toFixed(1)+"°";
lonValue.textContent=currentLongitude.toFixed(1)+"°";
latInput.value=currentLatitude.toFixed(4);
lonInput.value=currentLongitude.toFixed(4);
let h=Math.floor(currentTime/60), m=currentTime%60;
timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
const jd = currentDay + (currentTime / 1440);
dayValue.textContent=`Day ${jd.toFixed(4)}: ${dayToStr(currentDay, currentYear)}`;
updateSphere();
animate();

// ------------------- URL State Persistence -------------------
function saveStateToURL() {
  const params = new URLSearchParams();

  // Save datetime string if present
  const datetimeValue = document.getElementById('datetimeInput').value.trim();
  if (datetimeValue) {
    params.set('dt', datetimeValue);
  }

  // Save location string if present
  const locationValue = document.getElementById('locationInput').value.trim();
  if (locationValue) {
    params.set('loc', locationValue);
  }

  window.history.replaceState({}, '', `#${params.toString()}`);
}

function loadStateFromURL() {
  const hash = window.location.hash.substring(1);
  if (!hash) return false;

  window.isLoadingFromURL = true;
  const params = new URLSearchParams(hash);
  let hasState = false;

  // Load and parse datetime
  if (params.has('dt')) {
    const datetimeValue = params.get('dt');
    document.getElementById('datetimeInput').value = datetimeValue;

    const datetime = parser.parseFlexibleDateTime(datetimeValue);
    if (datetime) {
      updateSlidersFromDate(datetime);
      hasState = true;
    }
  }

  // Load location - we need to fetch coordinates from the geocoding API
  if (params.has('loc')) {
    const locationValue = params.get('loc');
    document.getElementById('locationInput').value = locationValue;

    // Fetch coordinates for this location
    (async () => {
      try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(locationValue)}&limit=1&addressdetails=1`;
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'ArmillarySphere/1.0'
          }
        });
        const places = await response.json();

        if (places.length > 0) {
          const lat = parseFloat(places[0].lat);
          const lon = parseFloat(places[0].lon);

          // Update latitude
          const clampedLat = Math.max(-66, Math.min(66, lat));
          currentLatitude = clampedLat;
          latSlider.value = clampedLat;
          latInput.value = clampedLat.toFixed(4);
          latValue.textContent = clampedLat.toFixed(1) + "°";

          // Update longitude
          const clampedLon = Math.max(-180, Math.min(180, lon));
          currentLongitude = clampedLon;
          lonSlider.value = clampedLon;
          lonInput.value = clampedLon.toFixed(4);
          lonValue.textContent = clampedLon.toFixed(1) + "°";

          // Update visualization
          updateSphere();

          // Save state back to URL to preserve it
          saveStateToURL();

          // Reset flag after a short delay to allow autocomplete to settle
          setTimeout(() => { window.isLoadingFromURL = false; }, 500);
        }
      } catch (error) {
        console.error('Failed to load location from URL:', error);
        // Reset flag even on error
        setTimeout(() => { window.isLoadingFromURL = false; }, 500);
      }
    })();

    hasState = true;
  } else {
    // No location to load, reset flag immediately
    window.isLoadingFromURL = false;
  }

  return hasState;
}

// Expose functions and variables to global scope for autocomplete
window.updateSphere = updateSphere;
window.currentLatitude = currentLatitude;
window.currentLongitude = currentLongitude;
window.saveStateToURL = saveStateToURL;
window.isLoadingFromURL = false;

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// ------------------- Star Hover Detection -------------------
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function onStarHover(event) {
  // Calculate mouse position in normalized device coordinates (-1 to +1)
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // Update the raycaster
  raycaster.setFromCamera(mouse, camera);

  // Get all objects in the star group (both stars and glows)
  const intersects = raycaster.intersectObjects(starGroup.children, false);

  const starInfoElement = document.getElementById('starInfo');

  if (intersects.length > 0) {
    const hoveredObject = intersects[0].object;
    if (hoveredObject.userData.name && hoveredObject.userData.constellation) {
      // Update star info content
      document.getElementById('starName').textContent = hoveredObject.userData.name;
      document.getElementById('constellationName').textContent = hoveredObject.userData.constellation;
      // Show with fade-in transition
      starInfoElement.classList.add('visible');
      // Change cursor to pointer
      renderer.domElement.style.cursor = 'pointer';
    }
  } else {
    // Hide star info with fade-out transition
    starInfoElement.classList.remove('visible');
    renderer.domElement.style.cursor = 'default';
  }
}

// Add mousemove listener to canvas for hover detection
renderer.domElement.addEventListener('mousemove', onStarHover);

// ------------------- DateTime Parser Integration -------------------
function dateToYearDay(date) {
  // Get day of year (1-365/366)
  const start = new Date(date.getFullYear(), 0, 0);
  const diff = date - start;
  const oneDay = 1000 * 60 * 60 * 24;
  return Math.floor(diff / oneDay);
}

function updateSlidersFromDate(date) {
  // Update day of year slider
  // More robust calculation that avoids timezone issues
  const month = date.getMonth();
  const day = date.getDate();
  const year = date.getFullYear();

  // Set the current year
  currentYear = year;

  // Days in each month (use leap year days if applicable)
  const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
  const monthDays = isLeapYear
    ? [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    : [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  let dayOfYear = day;
  for (let i = 0; i < month; i++) {
    dayOfYear += monthDays[i];
  }

  daySlider.value = dayOfYear;
  currentDay = dayOfYear;

  // Update time slider
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const timeInMinutes = hours * 60 + minutes;

  timeSlider.value = timeInMinutes;
  currentTime = timeInMinutes;
  timeValue.textContent = `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`;

  // Format the date string with actual year from input
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const jd = currentDay + (currentTime / 1440);
  dayValue.textContent = `Day ${jd.toFixed(4)}: ${monthNames[month]} ${day}, ${year}`;

  // Update the visualization
  updateSphere();
  saveStateToURL();
}

// Initialize datetime parser
const datetimeInput = document.getElementById('datetimeInput');
const parser = new DateTimeParser(datetimeInput, updateSlidersFromDate);

// Wire up "Now" button
const nowButton = document.getElementById('nowButton');
nowButton.addEventListener('click', (e) => {
  e.preventDefault();
  parser.setNow();
});

// Load state from URL after parser is initialized
loadStateFromURL();

</script>

<script>
// ------------------- Location Autocomplete -------------------
(function () {
  const maxResults = 20;
  const locationInput = document.querySelector("#locationInput");

  if (locationInput) {
    new autoComplete({
      debounce: 300,
      selector: "#locationInput",
      data: {
        src: async () => {
          const query = document.querySelector("#locationInput").value;
          if (query === "" || query.length < 3) {
            return;
          }

          try {
            // Using Nominatim (OpenStreetMap) geocoding API
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=${maxResults}&addressdetails=1`;
            const response = await fetch(url, {
              headers: {
                'User-Agent': 'ArmillarySphere/1.0' // Nominatim requires a user agent
              }
            });
            const places = await response.json();
            return places.map((place) => ({
              name: place.display_name,
              lat: parseFloat(place.lat),
              lon: parseFloat(place.lon),
            }));
          } catch (error) {
            console.error('Geocoding error:', error);
            return [];
          }
        },
        keys: ["name", "lat", "lon"],
      },
      resultsList: {
        maxResults: maxResults,
      },
      resultItem: {
        highlight: true,
      },
      shouldCacheSrc: false,
      events: {
        input: {
          selection(event) {
            // Ignore autocomplete selections during URL loading
            if (window.isLoadingFromURL) {
              return;
            }

            const feedback = event.detail;
            const selection = feedback.selection.value[feedback.selection.key];

            // Set location name
            document.querySelector("#locationInput").value = selection;

            // Set latitude
            const latField = document.querySelector("#latInput");
            const lat = feedback.selection.value.lat;
            latField.value = lat.toFixed(4);

            // Update latitude slider and display
            const latSlider = document.querySelector("#latSlider");
            const clampedLat = Math.max(-66, Math.min(66, lat));
            latSlider.value = clampedLat;
            window.currentLatitude = clampedLat;
            document.getElementById('latValue').textContent = clampedLat.toFixed(1) + "°";

            // Set longitude
            const lonField = document.querySelector("#lonInput");
            const lon = feedback.selection.value.lon;
            lonField.value = lon.toFixed(4);

            // Update longitude slider and display
            const lonSlider = document.querySelector("#lonSlider");
            const clampedLon = Math.max(-180, Math.min(180, lon));
            lonSlider.value = clampedLon;
            window.currentLongitude = clampedLon;
            document.getElementById('lonValue').textContent = clampedLon.toFixed(1) + "°";

            // Trigger the slider input events to update the module's local variables
            latSlider.dispatchEvent(new Event('input'));
            lonSlider.dispatchEvent(new Event('input'));

            // Update the sphere visualization
            window.updateSphere();

            // Save location to URL
            saveStateToURL();
          },
        },
        keyup(event) {
          const latInput = document.querySelector("#latInput");
          const lonInput = document.querySelector("#lonInput");
          if (event.target.value !== latInput.dataset.originalValue) {
            // Clear lat/lon when user types new location
            // (but not on initial load)
          }
        },
      },
    });
  }
})();
</script>
</body>
</html>
