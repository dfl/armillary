<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ASC/MC Visualization - Analytic</title>
<style>
  body { margin: 0; overflow: hidden; }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 4px;
  }
  #angles {
    position: absolute;
    top: 10px;
    right: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 4px;
    min-width: 150px;
  }
  #angles div {
    margin: 4px 0;
  }
  .angle-label {
    font-weight: bold;
  }
  #sunTimes {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    background: rgba(0,0,0,0.5);
    padding: 12px;
    border-radius: 4px;
    min-width: 150px;
  }
  #sunTimes div {
    margin: 4px 0;
  }
  .time-label {
    font-weight: bold;
  }
</style>
</head>
<body>

<div id="ui">
  DateTime: <input type="text" id="datetimeInput" placeholder="e.g., 'now', '2000-03-21 12:00', 'March 21 2000 noon'" style="width: 300px;">
  <button id="nowButton">Now</button>
  <br>
  <br>
  Latitude: <input type="text" id="latInput" placeholder="e.g., 40.7128, -33.8688" style="width: 80px;">
  <input type="range" id="latSlider" min="-66" max="66" value="0" step="0.1">
  <span id="latValue">0°</span>
  <br>
  Longitude: <input type="text" id="lonInput" placeholder="e.g., -74.0060, 151.2093" style="width: 80px;">
  <input type="range" id="lonSlider" min="-180" max="180" value="0" step="0.1">
  <span id="lonValue">0°</span>
  <br>
  Time: <input type="range" id="timeSlider" min="0" max="1439" value="720" step="1">
  <span id="timeValue">12:00</span>
  <br>
  Day of Year: <input type="range" id="daySlider" min="1" max="365" value="1" step="1">
  <span id="dayValue">Jan 1</span>
  <br>
  <label><input type="checkbox" id="starfieldToggle" checked> Show Starfield</label>
</div>

<div id="angles">
  <div><span class="angle-label">LST:</span> <span id="lstValue">--</span></div>
  <div><span class="angle-label">MC:</span> <span id="mcValue">--</span></div>
  <div><span class="angle-label">AC:</span> <span id="acValue">--</span></div>
</div>

<div id="sunTimes">
  <div><span class="time-label">Sunrise:</span> <span id="sunriseValue">--</span></div>
  <div><span class="time-label">Sunset:</span> <span id="sunsetValue">--</span></div>
</div>

<script type='text/javascript' src='./ephemeris-1.2.1.bundle.js' charset='utf-8'></script>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
    "chrono-node": "./node_modules/chrono-node/dist/esm/index.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import * as chrono from 'chrono-node';

// ------------------- DateTimeParser -------------------
class DateTimeParser {
  constructor(inputElement, onDateTimeParsed) {
    this.input = inputElement;
    this.onDateTimeParsed = onDateTimeParsed;
    this.setupEventListeners();
  }

  setupEventListeners() {
    this.input.addEventListener('blur', () => this.parse());
    this.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.parse();
      }
    });
  }

  setNow() {
    const now = new Date();
    this.input.value = 'now';
    this.onDateTimeParsed(now);
    this.showSuccess();
  }

  parse() {
    const text = this.input.value.trim();
    if (!text) return;

    const datetime = this.parseFlexibleDateTime(text);
    if (datetime) {
      this.onDateTimeParsed(datetime);
      this.showSuccess();
    } else {
      this.showError();
    }
  }

  parseFlexibleDateTime(text) {
    // Handle "now" keyword
    if (text.toLowerCase() === 'now') {
      return new Date();
    }

    const customParsed = this.parseCustomFormat(text);
    if (customParsed) return customParsed;

    // Use chrono-node for natural language parsing
    const results = chrono.parse(text);
    if (results.length > 0) {
      return results[0].start.date();
    }

    return null;
  }

  parseCustomFormat(text) {
    const cleanText = text.replace(/\s+/g, '').toLowerCase();

    const pattern1 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})$/;
    const match1 = cleanText.match(pattern1);
    if (match1) {
      const [, month, day, year, hours, minutes] = match1;
      return new Date(year, month - 1, day, hours, minutes, 0);
    }

    const pattern2 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{2})$/;
    const match2 = cleanText.match(pattern2);
    if (match2) {
      const [, month, day, year, hours, minutes, seconds] = match2;
      return new Date(year, month - 1, day, hours, minutes, seconds);
    }

    const pattern3 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(am|pm)$/;
    const match3 = cleanText.match(pattern3);
    if (match3) {
      let [, month, day, year, hours, minutes, ampm] = match3;
      hours = parseInt(hours);
      if (ampm === 'pm' && hours !== 12) hours += 12;
      if (ampm === 'am' && hours === 12) hours = 0;
      return new Date(year, month - 1, day, hours, minutes, 0);
    }

    const pattern4 = /^(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{2})(am|pm)$/;
    const match4 = cleanText.match(pattern4);
    if (match4) {
      let [, month, day, year, hours, minutes, seconds, ampm] = match4;
      hours = parseInt(hours);
      if (ampm === 'pm' && hours !== 12) hours += 12;
      if (ampm === 'am' && hours === 12) hours = 0;
      return new Date(year, month - 1, day, hours, minutes, seconds);
    }

    return null;
  }

  showSuccess() {
    this.input.style.borderColor = 'green';
    setTimeout(() => this.input.style.borderColor = '', 1000);
  }

  showError() {
    this.input.style.borderColor = 'red';
    setTimeout(() => this.input.style.borderColor = '', 2000);
  }
}

// ------------------- Scene Setup -------------------
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,2.5,-6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Set camera to look at origin
camera.lookAt(0, 0, 0);

// ------------------- Constants -------------------
const OBLIQUITY = 23.44 * Math.PI/180;
const CE_RADIUS = 3;

// ------------------- Groups -------------------
const celestial = new THREE.Group();
scene.add(celestial);

// ------------------- Fixed Reference Planes (green circles) -------------------
const planeOpts = { side: THREE.DoubleSide, transparent: true, opacity: 0.1 };

// Horizon plane (horizontal)
const horizonPlane = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS, 64),
  new THREE.MeshBasicMaterial({ color: 0x00ff00, ...planeOpts })
);
horizonPlane.rotation.x = -Math.PI/2; // horizontal
scene.add(horizonPlane);

// Horizon outline
const horizonOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  horizonOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const horizonOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(horizonOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
horizonOutline.rotation.x = -Math.PI/2;
scene.add(horizonOutline);

// Compass Rose - Traditional Nautical Style with Half-Filled Points
const compassRosetteGroup = new THREE.Group();

const solidMaterial = new THREE.MeshBasicMaterial({
  color: 0x00ff00,
  transparent: true,
  opacity: 0.2,
  side: THREE.DoubleSide
});

const outlineMaterial = new THREE.LineBasicMaterial({
  color: 0x00ff00,
  opacity: 0.25,
  transparent: true,
  linewidth: 0.5
});

// Create a compass point with one half solid, one half outline
function createSplitCompassPoint(angle, length, width, leftFilled) {
  const group = new THREE.Group();

  // Center point
  const center = new THREE.Vector3(0, 0, 0);
  // Tip of the point
  const tip = new THREE.Vector3(length * Math.sin(angle), 0, length * Math.cos(angle));
  // Left side
  const left = new THREE.Vector3(width * Math.sin(angle - Math.PI/2), 0, width * Math.cos(angle - Math.PI/2));
  // Right side
  const right = new THREE.Vector3(width * Math.sin(angle + Math.PI/2), 0, width * Math.cos(angle + Math.PI/2));

  if (leftFilled) {
    // Left half filled
    const leftShape = new THREE.Shape();
    leftShape.moveTo(0, 0);
    leftShape.lineTo(left.x, left.z);
    leftShape.lineTo(tip.x, tip.z);
    leftShape.lineTo(0, 0);

    const leftGeometry = new THREE.ShapeGeometry(leftShape);
    const leftMesh = new THREE.Mesh(leftGeometry, solidMaterial);
    leftMesh.rotation.x = -Math.PI / 2;
    group.add(leftMesh);

    // Add outline to filled half
    const leftOutlinePoints = [center.clone(), left.clone(), tip.clone(), center.clone()];
    const leftOutlineGeometry = new THREE.BufferGeometry().setFromPoints(leftOutlinePoints);
    const leftOutline = new THREE.Line(leftOutlineGeometry, outlineMaterial);
    group.add(leftOutline);

    // Right half outline only
    const rightPoints = [center.clone(), right.clone(), tip.clone(), center.clone()];
    const rightGeometry = new THREE.BufferGeometry().setFromPoints(rightPoints);
    const rightLine = new THREE.Line(rightGeometry, outlineMaterial);
    group.add(rightLine);
  } else {
    // Right half filled
    const rightShape = new THREE.Shape();
    rightShape.moveTo(0, 0);
    rightShape.lineTo(right.x, right.z);
    rightShape.lineTo(tip.x, tip.z);
    rightShape.lineTo(0, 0);

    const rightGeometry = new THREE.ShapeGeometry(rightShape);
    const rightMesh = new THREE.Mesh(rightGeometry, solidMaterial);
    rightMesh.rotation.x = -Math.PI / 2;
    group.add(rightMesh);

    // Add outline to filled half
    const rightOutlinePoints = [center.clone(), right.clone(), tip.clone(), center.clone()];
    const rightOutlineGeometry = new THREE.BufferGeometry().setFromPoints(rightOutlinePoints);
    const rightOutline = new THREE.Line(rightOutlineGeometry, outlineMaterial);
    group.add(rightOutline);

    // Left half outline only
    const leftPoints = [center.clone(), left.clone(), tip.clone(), center.clone()];
    const leftGeometry = new THREE.BufferGeometry().setFromPoints(leftPoints);
    const leftLine = new THREE.Line(leftGeometry, outlineMaterial);
    group.add(leftLine);
  }

  return group;
}

// All 8 points with alternating left/right fills for pinwheel effect
const allPoints = [
  { angle: 0, length: 1.0, width: 0.12, leftFilled: true },           // North
  { angle: Math.PI/4, length: 0.7, width: 0.10, leftFilled: false },  // NE
  { angle: Math.PI/2, length: 1.0, width: 0.12, leftFilled: true },   // East
  { angle: 3*Math.PI/4, length: 0.7, width: 0.10, leftFilled: false }, // SE
  { angle: Math.PI, length: 1.0, width: 0.12, leftFilled: true },     // South
  { angle: 5*Math.PI/4, length: 0.7, width: 0.10, leftFilled: false }, // SW
  { angle: 3*Math.PI/2, length: 1.0, width: 0.12, leftFilled: true }, // West
  { angle: 7*Math.PI/4, length: 0.7, width: 0.10, leftFilled: false }  // NW
];

allPoints.forEach(point => {
  const pointGroup = createSplitCompassPoint(point.angle, point.length, point.width, point.leftFilled);
  compassRosetteGroup.add(pointGroup);
});

// Position at horizon level
compassRosetteGroup.position.y = 0.01;
scene.add(compassRosetteGroup);

// Meridian outline (no filled plane, only outline)
const meridianOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  meridianOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const meridianOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(meridianOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
meridianOutline.rotation.y = Math.PI/2;
scene.add(meridianOutline);

// Prime vertical outline (no filled plane, only outline)
const pvOutlinePoints = [];
for (let i = 0; i <= 64; i++) {
  const angle = (i / 64) * Math.PI * 2;
  pvOutlinePoints.push(new THREE.Vector3(CE_RADIUS * Math.cos(angle), CE_RADIUS * Math.sin(angle), 0));
}
const pvOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(pvOutlinePoints),
  new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true })
);
// No rotation needed - default XY plane is vertical E/W
scene.add(pvOutline);

// ------------------- Celestial Equator -------------------
const ceqPoints = [];
for(let i=0;i<=128;i++){
  const a=(i/128)*Math.PI*2;
  ceqPoints.push(new THREE.Vector3(CE_RADIUS*Math.cos(a), CE_RADIUS*Math.sin(a),0));
}
const ceqOutline = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(ceqPoints),
  new THREE.LineDashedMaterial({color:0x00ffff, opacity:0.6, transparent:true, dashSize:0.5, gapSize:0.3})
);
ceqOutline.computeLineDistances();
// Celestial equator in XY plane (vertical at equator), poles along Z axis
celestial.add(ceqOutline);

// ------------------- Ecliptic -------------------
const ecliptic = new THREE.Mesh(
  new THREE.CircleGeometry(CE_RADIUS,128),
  new THREE.MeshBasicMaterial({ color:0x888888, side:THREE.DoubleSide, transparent:true, opacity:0.1 })
);
ecliptic.rotation.x = OBLIQUITY; // Tilt from celestial equator around equinox line
celestial.add(ecliptic);

// ------------------- Zodiac Labels -------------------
const zodiacGroup = new THREE.Group();
zodiacGroup.rotation.x = OBLIQUITY; // Match ecliptic tilt
celestial.add(zodiacGroup);

// Radial lines at 0° of each zodiac sign (every 30°)
const radialLineMaterial = new THREE.LineBasicMaterial({color:0x888888, opacity:0.3, transparent:true});
for(let i=0; i<12; i++){
  const angle = THREE.MathUtils.degToRad(i*30);
  const radialLine = new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0,0,0),
      new THREE.Vector3(CE_RADIUS*Math.cos(angle), CE_RADIUS*Math.sin(angle), 0)
    ]),
    radialLineMaterial
  );
  zodiacGroup.add(radialLine);
}

const zodiacRadius = 2.3;
const zodiacGlyphs = Array.from({length:12},(_,i)=>String.fromCodePoint(0x2648+i)+'\uFE0E');

zodiacGlyphs.forEach((glyph,i)=>{
  const angle = THREE.MathUtils.degToRad(i*30+15); // center at 15° of each sign
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 84px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(glyph,64,64);
  const texture = new THREE.CanvasTexture(canvas);
  const mat = new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1.2,1.2),mat);
  mesh.position.set(zodiacRadius*Math.cos(angle), zodiacRadius*Math.sin(angle),0);
  mesh.rotation.z = angle + Math.PI/2;
  zodiacGroup.add(mesh);
});

// ------------------- Compass Labels -------------------
const compassRadius = 2.5;
function addCompassLabel(text,x,z,rotZ=0){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=128;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='bold 64px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(text,64,64);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.MeshBasicMaterial({map:texture, transparent:true, opacity:0.5, side:THREE.DoubleSide, depthTest:false});
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(1,1),mat);
  mesh.position.set(x,0.01,z);
  mesh.rotation.x=-Math.PI/2;
  mesh.rotation.z=rotZ;
  scene.add(mesh);
}
addCompassLabel('N',0,compassRadius,0);
addCompassLabel('S',0,-compassRadius,Math.PI);
addCompassLabel('E',compassRadius,0,-Math.PI/2);
addCompassLabel('W',-compassRadius,0,Math.PI/2);

// ------------------- Celestial Poles -------------------
// Lines extending along polar axis (Z axis in celestial sphere's frame)
const polarLineMaterial = new THREE.LineBasicMaterial({color:0x00ffff, opacity:0.6, transparent:true});
const polarLineLength = 0.67;

const npLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, CE_RADIUS),
    new THREE.Vector3(0, 0, CE_RADIUS + polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(npLine);

const spLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, -CE_RADIUS),
    new THREE.Vector3(0, 0, -CE_RADIUS - polarLineLength)
  ]),
  polarLineMaterial
);
celestial.add(spLine);

// Labels at the ends of the polar axis lines
function addPoleLabel(name,z){
  const canvas=document.createElement('canvas'); canvas.width=128; canvas.height=64;
  const ctx=canvas.getContext('2d');
  ctx.fillStyle='white'; ctx.font='24px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(name,64,32);
  const texture=new THREE.CanvasTexture(canvas);
  const mat=new THREE.SpriteMaterial({map:texture, depthTest:false});
  const sprite=new THREE.Sprite(mat);
  sprite.scale.set(1,0.5,1);
  sprite.position.set(0,0,z);
  celestial.add(sprite);
}
addPoleLabel('NP', CE_RADIUS+polarLineLength);
addPoleLabel('SP', -CE_RADIUS-polarLineLength);

// ------------------- Star Map and Constellations -------------------
// Star data: [name, RA (hours), Dec (degrees), magnitude]
const starData = [
  // Ursa Major (Big Dipper)
  ['Dubhe', 11.062, 61.75, 1.8],
  ['Merak', 11.031, 56.38, 2.4],
  ['Phecda', 11.897, 53.69, 2.4],
  ['Megrez', 12.257, 57.03, 3.3],
  ['Alioth', 12.900, 55.96, 1.8],
  ['Mizar', 13.399, 54.93, 2.2],
  ['Alkaid', 13.792, 49.31, 1.9],
  // Orion
  ['Betelgeuse', 5.919, 7.41, 0.5],
  ['Rigel', 5.242, -8.20, 0.1],
  ['Bellatrix', 5.418, 6.35, 1.6],
  ['Mintaka', 5.533, -0.30, 2.2],
  ['Alnilam', 5.603, -1.20, 1.7],
  ['Alnitak', 5.679, -1.94, 1.8],
  ['Saiph', 5.796, -9.67, 2.1],
  // Ursa Minor (Little Dipper)
  ['Polaris', 2.530, 89.26, 2.0],
  ['Kochab', 14.845, 74.16, 2.1],
  ['Pherkad', 15.345, 71.83, 3.0],
  // Cassiopeia
  ['Schedar', 0.675, 56.54, 2.2],
  ['Caph', 0.153, 59.15, 2.3],
  ['Cih', 0.945, 60.72, 2.5],
  ['Ruchbah', 1.430, 60.24, 2.7],
  ['Segin', 1.911, 63.67, 3.4],
  // Leo
  ['Regulus', 10.139, 11.97, 1.4],
  ['Denebola', 11.817, 14.57, 2.1],
  ['Algieba', 10.333, 19.84, 2.6],
  // Taurus
  ['Aldebaran', 4.599, 16.51, 0.9],
  ['Elnath', 5.438, 28.61, 1.7],
  // Gemini
  ['Pollux', 7.755, 28.03, 1.2],
  ['Castor', 7.577, 31.89, 1.6],
  // Canis Major
  ['Sirius', 6.752, -16.72, -1.5],
  ['Adhara', 6.977, -28.97, 1.5],
  // Boötes
  ['Arcturus', 14.261, 19.18, -0.05],
  // Virgo
  ['Spica', 13.420, -11.16, 1.0],
  // Lyra
  ['Vega', 18.615, 38.78, 0.0],
  // Aquila
  ['Altair', 19.846, 8.87, 0.8],
  // Cygnus
  ['Deneb', 20.690, 45.28, 1.3],
  ['Albireo', 19.512, 27.96, 3.1],
  // Scorpius
  ['Antares', 16.490, -26.43, 1.1],
  // Crux (Southern Cross)
  ['Acrux', 12.443, -63.10, 0.8],
  ['Mimosa', 12.795, -59.69, 1.3],
  ['Gacrux', 12.519, -57.11, 1.6],
  // Centaurus
  ['Alpha Centauri', 14.661, -60.84, -0.3],
  ['Beta Centauri', 14.064, -60.37, 0.6],
  // Eridanus
  ['Achernar', 1.629, -57.24, 0.5],
  // Carina
  ['Canopus', 6.399, -52.70, -0.7]
];

// Constellation line connections: [star1_name, star2_name]
const constellationLines = [
  // Big Dipper
  ['Dubhe', 'Merak'],
  ['Merak', 'Phecda'],
  ['Phecda', 'Megrez'],
  ['Megrez', 'Alioth'],
  ['Alioth', 'Mizar'],
  ['Mizar', 'Alkaid'],
  ['Megrez', 'Dubhe'],
  // Little Dipper
  ['Polaris', 'Kochab'],
  ['Kochab', 'Pherkad'],
  // Orion
  ['Betelgeuse', 'Bellatrix'],
  ['Bellatrix', 'Mintaka'],
  ['Mintaka', 'Alnilam'],
  ['Alnilam', 'Alnitak'],
  ['Alnitak', 'Saiph'],
  ['Saiph', 'Rigel'],
  ['Rigel', 'Betelgeuse'],
  ['Betelgeuse', 'Mintaka'],
  ['Alnilam', 'Rigel'],
  // Cassiopeia (W shape)
  ['Caph', 'Schedar'],
  ['Schedar', 'Cih'],
  ['Cih', 'Ruchbah'],
  ['Ruchbah', 'Segin'],
  // Leo (simplified)
  ['Regulus', 'Algieba'],
  ['Regulus', 'Denebola'],
  // Gemini
  ['Castor', 'Pollux'],
  // Summer Triangle
  ['Vega', 'Altair'],
  ['Altair', 'Deneb'],
  ['Deneb', 'Vega'],
  // Cygnus (Northern Cross)
  ['Deneb', 'Albireo'],
  // Southern Cross
  ['Acrux', 'Gacrux'],
  ['Mimosa', 'Gacrux']
];

// Convert RA/Dec to cartesian coordinates on celestial sphere
function raDecToVector3(ra_hours, dec_deg, radius) {
  // RA: 0-24 hours, convert to radians (0-2π)
  // Dec: -90 to +90 degrees
  const ra = (ra_hours / 24) * Math.PI * 2;
  const dec = THREE.MathUtils.degToRad(dec_deg);

  // Spherical to Cartesian conversion
  // In celestial coordinates: RA is angle in equatorial plane, Dec is elevation
  // X-Y plane is celestial equator, Z is towards north celestial pole
  const x = radius * Math.cos(dec) * Math.cos(ra);
  const y = radius * Math.cos(dec) * Math.sin(ra);
  const z = radius * Math.sin(dec);

  return new THREE.Vector3(x, y, z);
}

// Create star field
const starGroup = new THREE.Group();
const starMeshes = {};

starData.forEach(([name, ra, dec, mag]) => {
  // Star size based on magnitude (brighter = larger)
  // Magnitude scale is inverted (smaller number = brighter)
  const size = Math.max(0.02, 0.12 - mag * 0.02);

  // Star brightness based on magnitude
  const brightness = Math.max(0.3, 1.0 - mag * 0.15);

  const starGeometry = new THREE.SphereGeometry(size, 8, 8);
  const starMaterial = new THREE.MeshBasicMaterial({
    color: new THREE.Color(brightness, brightness, brightness * 0.95)
  });

  const star = new THREE.Mesh(starGeometry, starMaterial);
  const position = raDecToVector3(ra, dec, CE_RADIUS * 3.0);
  star.position.copy(position);

  starGroup.add(star);
  starMeshes[name] = star;
});

// Add constellation lines
const constellationLineGroup = new THREE.Group();
const lineMaterial = new THREE.LineBasicMaterial({
  color: 0x4444ff,
  transparent: true,
  opacity: 0.4
});

constellationLines.forEach(([star1, star2]) => {
  if (starMeshes[star1] && starMeshes[star2]) {
    const points = [
      starMeshes[star1].position.clone(),
      starMeshes[star2].position.clone()
    ];
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    constellationLineGroup.add(line);
  }
});

// Add star field and constellation lines to celestial sphere
celestial.add(starGroup);
celestial.add(constellationLineGroup);

// Add background star field (smaller, dimmer stars for atmosphere)
const bgStarCount = 800;
const bgStarGeometry = new THREE.BufferGeometry();
const bgStarPositions = [];
const bgStarColors = [];

for (let i = 0; i < bgStarCount; i++) {
  // Random position on sphere
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  const r = CE_RADIUS * 2.9;

  const x = r * Math.sin(phi) * Math.cos(theta);
  const y = r * Math.sin(phi) * Math.sin(theta);
  const z = r * Math.cos(phi);

  bgStarPositions.push(x, y, z);

  // Vary brightness
  const brightness = 0.3 + Math.random() * 0.5;
  bgStarColors.push(brightness, brightness, brightness * 0.98);
}

bgStarGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bgStarPositions, 3));
bgStarGeometry.setAttribute('color', new THREE.Float32BufferAttribute(bgStarColors, 3));

const bgStarMaterial = new THREE.PointsMaterial({
  size: 0.03,
  vertexColors: true,
  transparent: true,
  opacity: 0.8
});

const bgStarField = new THREE.Points(bgStarGeometry, bgStarMaterial);
celestial.add(bgStarField);

// ------------------- Sun -------------------
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(0.15,32,32),
  new THREE.MeshBasicMaterial({color:0xffff88})
);
zodiacGroup.add(sun); // Add to zodiacGroup so it's on the ecliptic plane

// Add sun glow effect
const sunGlow = new THREE.Mesh(
  new THREE.SphereGeometry(0.25, 32, 32),
  new THREE.MeshBasicMaterial({
    color: 0xffff00,
    transparent: true,
    opacity: 0.3
  })
);
zodiacGroup.add(sunGlow);

// ------------------- Sliders -------------------
let currentLatitude=0;
let currentLongitude=0;
let currentTime=720;
let currentDay=1;

const latSlider=document.getElementById('latSlider');
const latValue=document.getElementById('latValue');
const lonSlider=document.getElementById('lonSlider');
const lonValue=document.getElementById('lonValue');
const timeSlider=document.getElementById('timeSlider');
const timeValue=document.getElementById('timeValue');
const daySlider=document.getElementById('daySlider');
const dayValue=document.getElementById('dayValue');

function dayToStr(day){
  const md=[31,29,31,30,31,30,31,31,30,31,30,31];
  const mn=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  let d=day;
  for(let i=0;i<12;i++){
    if(d<=md[i]) return `${mn[i]} ${d}`;
    d-=md[i];
  }
  return 'Dec 31';
}

// ------------------- Celestial Sphere Update -------------------
function updateSphere(){
  const latRad = THREE.MathUtils.degToRad(currentLatitude);

  // Calculate Local Sidereal Time first (needed for celestial rotation)
  const J2000_epoch = 2451545.0;

  // Adjust time for longitude: 15° longitude = 1 hour time difference
  const longitudeTimeOffset = (currentLongitude / 15) * 60; // Convert to minutes
  const localTime = currentTime + longitudeTimeOffset;

  const daysFromJ2000 = (currentDay - 1) + (localTime / 1440);
  const julianDate = 2451544.5 + daysFromJ2000;

  // Greenwich Sidereal Time at 0h UT (simplified formula)
  const T = (julianDate - J2000_epoch) / 36525;
  const GST0 = 280.46061837 + 360.98564736629 * (julianDate - J2000_epoch) + 0.000387933 * T * T;

  // Local Sidereal Time = GST + longitude (in degrees)
  let LST = (GST0 + currentLongitude + (localTime / 1440) * 360) % 360;
  if (LST < 0) LST += 360;

  // Rotate celestial sphere based on LST (sidereal time, not solar time!)
  const lstAngle = THREE.MathUtils.degToRad(LST);

  // Set rotation order: X rotation (latitude tilt) then Z rotation (sidereal time)
  celestial.rotation.order = 'XZY';
  celestial.rotation.x = -latRad; // Tilt polar axis from north (Z) towards zenith (Y)
  celestial.rotation.z = lstAngle; // Rotate based on Local Sidereal Time
  celestial.rotation.y = 0;

  // Sun position - Convert day of year to month/day
  let sunLonRad;
  let sunBodyData = null; // Save for rise/set calculation

  // Convert day of year (1-365) to month and day
  const monthDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // 2000 is leap year
  let remainingDays = currentDay;
  let month = 0;
  let day = 1;
  for (let i = 0; i < 12; i++) {
    if (remainingDays <= monthDays[i]) {
      month = i;
      day = remainingDays;
      break;
    }
    remainingDays -= monthDays[i];
  }

  // Convert time (minutes since midnight) to hours/minutes
  const hours = Math.floor(currentTime / 60);
  const minutes = currentTime % 60;

  // Use ephemeris if available, otherwise fall back to approximation
  if (typeof $moshier !== 'undefined') {
    try {
      // Set observer location
      $const.tlong = currentLongitude;  // Observer longitude
      $const.glat = currentLatitude;  // Observer latitude

      // Set date
      const date = {
        year: 2000,
        month: month + 1,  // Moshier uses 1-12, not 0-11
        day: day,
        hours: hours,
        minutes: minutes,
        seconds: 0
      };

      // Initialize and calculate position
      $processor.init();
      const body = $moshier.body.sun;
      $processor.calc(date, body);

      // Calculate rise and set times
      // Note: riset needs to be called separately and uses a date at the start of the day
      const dateForRiset = {
        year: 2000,
        month: month + 1,
        day: day,
        hours: 0,
        minutes: 0,
        seconds: 0
      };

      // Note: Ephemeris rise/set not used - we calculate from scratch below

      sunBodyData = body; // Save for later use (now includes rise/set if available)

      // Get Sun's ecliptic longitude from the result
      // The ecliptic longitude should be in body.position.rect or body.position.polar
      // Moshier returns longitude in radians in body.position.longitude or similar
      if (body.position && body.position.apparentLongitude !== undefined) {
        sunLonRad = THREE.MathUtils.degToRad(body.position.apparentLongitude);
      } else if (body.position && body.position.polar) {
        sunLonRad = THREE.MathUtils.degToRad(body.position.polar[0]);
      } else {
        // Fallback to approximation if structure is unexpected
        console.warn('Unexpected ephemeris data structure, using approximation');
        const sunLon = (280 + (currentDay-1)*(360/365))%360;
        sunLonRad = THREE.MathUtils.degToRad(sunLon);
      }
    } catch (e) {
      console.warn('Ephemeris calculation failed, using approximation:', e);
      // Fallback to approximation
      const sunLon = (280 + (currentDay-1)*(360/365))%360;
      sunLonRad = THREE.MathUtils.degToRad(sunLon);
    }
  } else {
    // Simple approximation for year 2000
    const sunLon = (280 + (currentDay-1)*(360/365))%360;
    sunLonRad = THREE.MathUtils.degToRad(sunLon);
  }

  // Position Sun on ecliptic (in zodiacGroup's coordinate system)
  // Offset slightly above ecliptic plane (positive Z) to avoid being blocked by ecliptic fill
  sun.position.set(CE_RADIUS*Math.cos(sunLonRad), CE_RADIUS*Math.sin(sunLonRad), 0.05);
  sunGlow.position.copy(sun.position);

  // ------------------- Calculate Astrological Angles (MC, IC, AC, DSC) -------------------
  // Using traditional astrological formulas (not geometric intersections)
  //
  // MC (Midheaven): Ecliptic degree where RA = LST (equatorial meridian)
  // AC (Ascendant): Ecliptic degree rising on eastern horizon

  const epsilon = OBLIQUITY;
  const lstRad = THREE.MathUtils.degToRad(LST);

  // MC Formula: tan(MC) = tan(RAMC) / cos(ε), where RAMC = LST
  // Derivation: Convert equatorial coordinates (RA=LST, Dec=0) to ecliptic longitude
  let MC = THREE.MathUtils.radToDeg(
    Math.atan2(Math.sin(lstRad), Math.cos(lstRad) * Math.cos(epsilon))
  );
  if (MC < 0) MC += 360;

  // IC: Opposite point (180° from MC)
  let IC = (MC + 180) % 360;

  // AC Formula: tan(AC) = -cos(RAMC) / (sin(RAMC)*cos(ε) + tan(lat)*sin(ε))
  // Derivation: Ecliptic degree on eastern horizon at observer's latitude
  const tanLat = Math.tan(latRad);
  let AC = THREE.MathUtils.radToDeg(
    Math.atan2(-Math.cos(lstRad), Math.sin(lstRad) * Math.cos(epsilon) + tanLat * Math.sin(epsilon))
  );
  if (AC < 0) AC += 360;

  // DSC: Opposite point (180° from AC)
  let DSC = (AC + 180) % 360;

  // Convert to zodiac notation (sign + degree)
  function toZodiacString(longitude) {
    const signs = ['♈\uFE0E', '♉\uFE0E', '♊\uFE0E', '♋\uFE0E', '♌\uFE0E', '♍\uFE0E', '♎\uFE0E', '♏\uFE0E', '♐\uFE0E', '♑\uFE0E', '♒\uFE0E', '♓\uFE0E'];
    const signIndex = Math.floor(longitude / 30);
    const degree = longitude % 30;
    const minutes = Math.floor((degree % 1) * 60);
    const wholeDegs = Math.floor(degree);
    return `${wholeDegs.toString().padStart(2, '0')}${signs[signIndex]}${minutes.toString().padStart(2, '0')}`;
  }

  function lstToTimeString(lst) {
    const hours = Math.floor(lst / 15);
    const minutes = Math.floor((lst % 15) * 4);
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }

  // Validation: Verify calculations match expected values
  // Set to true to enable verification logging
  const verifyAngles = false;
  if (verifyAngles) {
    console.log('=== Astrological Angles ===');
    console.log('Location: Lat', currentLatitude.toFixed(2), '° | Lon', currentLongitude.toFixed(2), '°');
    console.log('LST:', LST.toFixed(2), '° (', lstToTimeString(LST), ')');
    console.log('MC:', MC.toFixed(2), '° =', toZodiacString(MC));
    console.log('IC:', IC.toFixed(2), '° =', toZodiacString(IC));
    console.log('AC:', AC.toFixed(2), '° =', toZodiacString(AC));
    console.log('DSC:', DSC.toFixed(2), '° =', toZodiacString(DSC));
  }

  // Update display
  document.getElementById('lstValue').textContent = lstToTimeString(LST);
  document.getElementById('mcValue').textContent = toZodiacString(MC);
  document.getElementById('acValue').textContent = toZodiacString(AC);

  // Calculate geometric intersections for visual sphere positioning
  // These are where the ecliptic actually crosses meridian/horizon in 3D space
  // (Different from astrological MC/AC which use equatorial definitions)
  const combinedTilt = epsilon - latRad; // ε - lat

  // Geometric MC: Where ecliptic crosses meridian plane (X=0) - upper
  let MC_visual = THREE.MathUtils.radToDeg(
    Math.atan2(Math.cos(lstRad), Math.cos(combinedTilt) * Math.sin(lstRad))
  );
  if (MC_visual < 0) MC_visual += 360;

  // Geometric IC: Opposite point - lower
  let IC_visual = (MC_visual + 180) % 360;

  // Geometric ASC: Where ecliptic crosses horizon plane (Y=0) - eastern
  let AC_visual = THREE.MathUtils.radToDeg(
    Math.atan2(-Math.sin(lstRad), Math.cos(combinedTilt) * Math.cos(lstRad))
  );
  if (AC_visual < 0) AC_visual += 360;

  // Geometric DSC: Opposite point - western
  let DSC_visual = (AC_visual + 180) % 360;

  // Use geometric positions for sphere placement
  const mcRad_ecliptic = THREE.MathUtils.degToRad(MC_visual);
  const icRad_ecliptic = THREE.MathUtils.degToRad(IC_visual);
  const acRad_ecliptic = THREE.MathUtils.degToRad(AC_visual);
  const dscRad_ecliptic = THREE.MathUtils.degToRad(DSC_visual);

  // Transform from ecliptic longitude to scene (horizon) coordinates:
  // 1. Start at point on ecliptic (XY plane)
  // 2. Apply obliquity (ε) - converts ecliptic → equatorial coords
  // 3. Apply latitude tilt - tilts celestial sphere for observer's location
  // 4. Apply LST rotation - rotates sphere to current sidereal time
  //
  // Result: MC ends up on meridian, AC on eastern horizon
  const eclipticToScene = (lonRad) => {
    return new THREE.Vector3(CE_RADIUS * Math.cos(lonRad), CE_RADIUS * Math.sin(lonRad), 0.05)
      .applyEuler(new THREE.Euler(OBLIQUITY, 0, 0, 'XYZ'))  // Obliquity
      .applyEuler(new THREE.Euler(celestial.rotation.x, 0, celestial.rotation.z, 'XZY')); // Lat + LST
  };

  spheres["MC"].position.copy(eclipticToScene(mcRad_ecliptic));
  spheres["IC"].position.copy(eclipticToScene(icRad_ecliptic));
  spheres["ASC"].position.copy(eclipticToScene(acRad_ecliptic));
  spheres["DSC"].position.copy(eclipticToScene(dscRad_ecliptic));

  // Update angle labels to follow sphere positions
  if (window.angleLabels) {
    window.angleLabels.MC.position.copy(spheres["MC"].position);
    window.angleLabels.MC.position.y += 0.3; // Offset above sphere
    window.angleLabels.IC.position.copy(spheres["IC"].position);
    window.angleLabels.IC.position.y -= 0.3; // Offset below sphere
    window.angleLabels.ASC.position.copy(spheres["ASC"].position);
    window.angleLabels.ASC.position.x += 0.3; // Offset to the right
    window.angleLabels.DSC.position.copy(spheres["DSC"].position);
    window.angleLabels.DSC.position.x -= 0.3; // Offset to the left
  }

  // Verify positioning (can be disabled after verification)
  const verifyPositions = false;
  if (verifyPositions) {
    console.log('=== Astrological vs Geometric Angles ===');
    console.log('MC (astrological):', MC.toFixed(2), '° =', toZodiacString(MC));
    console.log('MC (geometric):', MC_visual.toFixed(2), '° =', toZodiacString(MC_visual));
    console.log('Difference:', Math.abs(MC - MC_visual).toFixed(2), '°');
    console.log('');
    console.log('AC (astrological):', AC.toFixed(2), '° =', toZodiacString(AC));
    console.log('AC (geometric):', AC_visual.toFixed(2), '° =', toZodiacString(AC_visual));
    console.log('Difference:', Math.abs(AC - AC_visual).toFixed(2), '°');
    console.log('');
    console.log('Sphere positions:');
    console.log('MC on meridian (X ≈ 0):', spheres["MC"].position.x.toFixed(4));
    console.log('ASC on horizon (Y ≈ 0):', spheres["ASC"].position.y.toFixed(4));
  }

  // ------------------- Calculate Sunrise and Sunset (from scratch) -------------------
  // Calculate rise/set times based on sun's ecliptic longitude
  // Algorithm: Convert ecliptic to equatorial, calculate hour angle, find rise/set times

  function calculateRiseSet(sunEclipticLon, latitude, longitude, dayOfYear) {
    // Constants
    const OBLIQUITY_RAD = epsilon;
    const SUN_ANGULAR_RADIUS = 0.267 * Math.PI / 180; // 16 arcminutes
    const ATMOSPHERIC_REFRACTION = 0.567 * Math.PI / 180; // 34 arcminutes
    const ALTITUDE_AT_RISE_SET = -(SUN_ANGULAR_RADIUS + ATMOSPHERIC_REFRACTION); // -0.833 degrees

    // Convert ecliptic longitude to equatorial coordinates (RA, Dec)
    // For the sun, ecliptic latitude β ≈ 0
    const sinDec = Math.sin(OBLIQUITY_RAD) * Math.sin(sunEclipticLon);
    const declination = Math.asin(sinDec);

    const rightAscension = Math.atan2(
      Math.sin(sunEclipticLon) * Math.cos(OBLIQUITY_RAD),
      Math.cos(sunEclipticLon)
    );
    const RA_deg = THREE.MathUtils.radToDeg(rightAscension);
    const RA_norm = RA_deg < 0 ? RA_deg + 360 : RA_deg;

    // Calculate hour angle when sun is at horizon
    const latRad = THREE.MathUtils.degToRad(latitude);
    const cosHourAngle = (Math.sin(ALTITUDE_AT_RISE_SET) - Math.sin(latRad) * Math.sin(declination)) /
                         (Math.cos(latRad) * Math.cos(declination));

    // Check for no sunrise/sunset (polar regions)
    if (cosHourAngle > 1) {
      return { sunrise: "No sunrise", sunset: "No sunset", transit: "--:--" };
    }
    if (cosHourAngle < -1) {
      return { sunrise: "24h sun", sunset: "24h sun", transit: "--:--" };
    }

    // Hour angle in degrees (0-180)
    const H_deg = THREE.MathUtils.radToDeg(Math.acos(cosHourAngle));

    // Calculate Greenwich Sidereal Time at 0h UT for this day
    const julianDate0h = 2451544.5 + (dayOfYear - 1); // JD for year 2000
    const T = (julianDate0h - J2000_epoch) / 36525;
    const GST0 = 280.46061837 + 360.98564736629 * (julianDate0h - J2000_epoch) +
                 0.000387933 * T * T - 0.0000000258 * T * T * T;

    // Calculate transit time (when RA = LST)
    // LST = GST + longitude, so at transit: GST = RA - longitude
    // Time in UT when this occurs: (RA - longitude - GST0) / 360.98564736629 * 24 hours
    let transitUT = ((RA_norm - longitude - GST0) / 360.98564736629) * 24; // hours

    // Normalize to 0-24 range
    while (transitUT < 0) transitUT += 24;
    while (transitUT >= 24) transitUT -= 24;

    // Sunrise and sunset times (UT)
    const H_hours = H_deg / 15; // Convert hour angle from degrees to hours
    let sunriseUT = transitUT - H_hours;
    let sunsetUT = transitUT + H_hours;

    // Normalize to 0-24 range
    while (sunriseUT < 0) sunriseUT += 24;
    while (sunriseUT >= 24) sunriseUT -= 24;
    while (sunsetUT < 0) sunsetUT += 24;
    while (sunsetUT >= 24) sunsetUT -= 24;

    // Convert from UT to local solar time (add longitude offset)
    const lonTimeOffset = longitude / 15; // hours
    let sunriseLocal = sunriseUT + lonTimeOffset;
    let sunsetLocal = sunsetUT + lonTimeOffset;
    let transitLocal = transitUT + lonTimeOffset;

    // Normalize to 0-24 range
    while (sunriseLocal < 0) sunriseLocal += 24;
    while (sunriseLocal >= 24) sunriseLocal -= 24;
    while (sunsetLocal < 0) sunsetLocal += 24;
    while (sunsetLocal >= 24) sunsetLocal -= 24;
    while (transitLocal < 0) transitLocal += 24;
    while (transitLocal >= 24) transitLocal -= 24;

    // Format as HH:MM
    const formatTime = (hours) => {
      const h = Math.floor(hours);
      const m = Math.floor((hours - h) * 60);
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
    };

    return {
      sunrise: formatTime(sunriseLocal),
      sunset: formatTime(sunsetLocal),
      transit: formatTime(transitLocal)
    };
  }

  // Calculate sunrise/sunset using our from-scratch implementation
  const riseSetData = calculateRiseSet(sunLonRad, currentLatitude, currentLongitude, currentDay);

  document.getElementById('sunriseValue').textContent = riseSetData.sunrise;
  document.getElementById('sunsetValue').textContent = riseSetData.sunset;
}

// ------------------- Angle Spheres -------------------
const spheres={};
function addAngle(name,color){
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(0.12,16,16),
    new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.6})
  );
  scene.add(mesh); // Add to scene, not celestial - these are horizon-fixed angles
  spheres[name]=mesh;
}
addAngle("MC",0x888888);
addAngle("IC",0x888888);
addAngle("ASC",0x888888);
addAngle("DSC",0x888888);

// ------------------- Angle Labels -------------------
function addAngleLabel(name) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.font = 'bold 32px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(name, 64, 32);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
  const sprite = new THREE.Sprite(material);
  sprite.scale.set(0.8, 0.4, 1);
  scene.add(sprite);
  return sprite;
}

window.angleLabels = {
  MC: addAngleLabel('MC'),
  IC: addAngleLabel('IC'),
  ASC: addAngleLabel('ASC'),
  DSC: addAngleLabel('DSC')
};

// ------------------- Lat/Lon Text Input Elements -------------------
const latInput=document.getElementById('latInput');
const lonInput=document.getElementById('lonInput');

// ------------------- Slider Listeners -------------------
latSlider.addEventListener('input',()=>{
  currentLatitude=parseFloat(latSlider.value);
  latValue.textContent=currentLatitude.toFixed(1)+"°";
  latInput.value=currentLatitude.toFixed(4);
  updateSphere();
});

lonSlider.addEventListener('input',()=>{
  currentLongitude=parseFloat(lonSlider.value);
  lonValue.textContent=currentLongitude.toFixed(1)+"°";
  lonInput.value=currentLongitude.toFixed(4);
  updateSphere();
});

timeSlider.addEventListener('input',()=>{currentTime=parseFloat(timeSlider.value);let h=Math.floor(currentTime/60);let m=currentTime%60;timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;updateSphere();});
daySlider.addEventListener('input',()=>{currentDay=parseFloat(daySlider.value);dayValue.textContent=`Day ${currentDay}: ${dayToStr(currentDay)}`;updateSphere();});

// ------------------- Lat/Lon Text Input Listeners -------------------
function parseLatInput() {
  const value = parseFloat(latInput.value);
  if (!isNaN(value)) {
    // Clamp to valid range
    const clamped = Math.max(-66, Math.min(66, value));
    currentLatitude = clamped;
    latSlider.value = clamped;
    latValue.textContent = clamped.toFixed(1) + "°";
    latInput.value = clamped.toFixed(4);
    latInput.style.borderColor = 'green';
    setTimeout(() => latInput.style.borderColor = '', 1000);
    updateSphere();
  } else {
    latInput.style.borderColor = 'red';
    setTimeout(() => latInput.style.borderColor = '', 2000);
  }
}

function parseLonInput() {
  const value = parseFloat(lonInput.value);
  if (!isNaN(value)) {
    // Clamp to valid range
    const clamped = Math.max(-180, Math.min(180, value));
    currentLongitude = clamped;
    lonSlider.value = clamped;
    lonValue.textContent = clamped.toFixed(1) + "°";
    lonInput.value = clamped.toFixed(4);
    lonInput.style.borderColor = 'green';
    setTimeout(() => lonInput.style.borderColor = '', 1000);
    updateSphere();
  } else {
    lonInput.style.borderColor = 'red';
    setTimeout(() => lonInput.style.borderColor = '', 2000);
  }
}

latInput.addEventListener('blur', parseLatInput);
latInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    parseLatInput();
  }
});

lonInput.addEventListener('blur', parseLonInput);
lonInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    parseLonInput();
  }
});

// ------------------- Starfield Toggle -------------------
const starfieldToggle = document.getElementById('starfieldToggle');
starfieldToggle.addEventListener('change', () => {
  const visible = starfieldToggle.checked;
  starGroup.visible = visible;
  constellationLineGroup.visible = visible;
  bgStarField.visible = visible;
});

// ------------------- Animate -------------------
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}

currentLatitude=parseFloat(latSlider.value);
currentLongitude=parseFloat(lonSlider.value);
currentTime=parseFloat(timeSlider.value);
currentDay=parseFloat(daySlider.value);
latValue.textContent=currentLatitude.toFixed(1)+"°";
lonValue.textContent=currentLongitude.toFixed(1)+"°";
latInput.value=currentLatitude.toFixed(4);
lonInput.value=currentLongitude.toFixed(4);
let h=Math.floor(currentTime/60), m=currentTime%60;
timeValue.textContent=`${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
dayValue.textContent=`Day ${currentDay}: ${dayToStr(currentDay)}`;
updateSphere();
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// ------------------- DateTime Parser Integration -------------------
function dateToYearDay(date) {
  // Get day of year (1-365/366)
  const start = new Date(date.getFullYear(), 0, 0);
  const diff = date - start;
  const oneDay = 1000 * 60 * 60 * 24;
  return Math.floor(diff / oneDay);
}

function updateSlidersFromDate(date) {
  // Update day of year slider
  // For year 2000 simulation (leap year)
  // More robust calculation that avoids timezone issues
  const month = date.getMonth();
  const day = date.getDate();

  // Days in each month for leap year 2000
  const monthDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  let dayOfYear = day;
  for (let i = 0; i < month; i++) {
    dayOfYear += monthDays[i];
  }

  daySlider.value = dayOfYear;
  currentDay = dayOfYear;
  dayValue.textContent = `Day ${currentDay}: ${dayToStr(currentDay)}`;

  // Update time slider
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const timeInMinutes = hours * 60 + minutes;

  timeSlider.value = timeInMinutes;
  currentTime = timeInMinutes;
  timeValue.textContent = `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`;

  // Update the visualization
  updateSphere();
}

// Initialize datetime parser
const datetimeInput = document.getElementById('datetimeInput');
const parser = new DateTimeParser(datetimeInput, updateSlidersFromDate);

// Wire up "Now" button
const nowButton = document.getElementById('nowButton');
nowButton.addEventListener('click', (e) => {
  e.preventDefault();
  parser.setNow();
});

</script>
</body>
</html>
